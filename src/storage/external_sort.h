/*
 * Copyright (C) 2008 NHN Corporation
 * Copyright (C) 2008 CUBRID Co., Ltd.
 *
 * external_sort.h - External sorting module 
 */

#ifndef _EXTERNAL_SORT_H_
#define _EXTERNAL_SORT_H_

#ident "$Id$"

#include "error_manager.h"
#include "common.h"
#include "qp_list.h"
#include "thread_impl.h"

#define SORT_PUT_STOP     2

typedef enum
{
  SORT_REC_DOESNT_FIT,
  SORT_SUCCESS,
  SORT_NOMORE_RECS,
  SORT_ERROR_OCCURRED
} SORT_STATUS;

typedef enum
{
  SORT_ELIM_DUP,		/* eliminate duplicate */
  SORT_DUP			/* allow duplicate */
} SORT_DUP_OPTION;

typedef SORT_STATUS SORT_GET_FUNC (THREAD_ENTRY * thread_p, RECDES *, void *);
typedef int SORT_PUT_FUNC (THREAD_ENTRY * thread_p, const RECDES *, void *);
typedef int SORT_CMP_FUNC (const void *, const void *, void *);

/*
 * When sorting a list file, we extract the key fields from each list
 * file record and send only those fields (and a record identifier) to
 * the sort module.  The sort module sorts those abbreviated records, and
 * when it is finally finished we build the output file by copying
 * records from the input file to the output file in the order given by
 * the sorted abbreviated records.  The assumption is that the page
 * traffic generated by (probably randomly) hopping around in the input
 * file is more than paid back by reduced io during sorting.  Since in
 * most cases we're only sorting on one field anyway, this can lead to
 * substantial speedups in sorting.  In practice we've seen tremendous
 * speedups.  (However, if we know that we're sorting on all of the
 * fields, we omit the record identifier and simply reconstruct the
 * original record from the keys during output.)
 *
 * For pervsity's sake, the records submitted to the sort module differ
 * in layout from the list file records (someday the list files should
 * probably be changed to the multikey version of this format, since it
 * makes random access to the fields of the record much cheaper).
 * Single-key sorts are handled slightly differently from multi-key
 * sorts, although it's not so clear anymore that the optimization is
 * worth the extra work.
 *
 * The sort information is broken into two components.  The first is the
 * per-sort information such as the number of columns, whether each
 * column is ascending or descending, etc.  This information is held in a
 * SORT_INFO structure; the information about the keys themselves is held
 * in the SORTKEY_INFO structure, whose main component is an array of
 * SUBKEY_INFO structures, one for each sort column.  Each SUBKEY_INFO
 * structure features a column number that identifies the key column in
 * the input list file, a type-specific function pointer, and an
 * indicator of whether the column is to be sorted in ascending or
 * descending order.
 *
 * The second component of the sort information is per-record info, and
 * it is captured in the SORT_REC structures that are fed to the sort
 * module.  These records comprise an array of offsets that locate the
 * actual data for the keys (a zero entry indicates that the
 * corresponding key is null) and a record identifier that allows us to
 * locate the original record in the input file.  The actual data for the
 * keys is laid down after the offset array.
 */

/* 
 * sort_key consist of <header|body>. 
 * data structure of sort_key body is the same as that of tuple body.
 *
 * sort_key is classfied to P_sort_key and A_sort_key.
 * 
 * P_sort_key data structure: 
 *
 * <------------ header(8) -----------> 
 * +-----------+----------+-----------+------+
 * | pageid(4) | voiid(2) | offset(2) | body |
 * +-----------+----------+-----------+------+
 *
 * A_sort_key data structure:
 *
 * 1) n is odd 
 * <---------------- header ----------------->
 * +-----------+-----------+-----+-----------+------+
 * | offset[0] | offset[1] | ... | offset[n] | body |
 * +-----------+-----------+-----+-----------+------+
 * <---- 4 ---->
 *
 * 2) n is even
 * <----------------------- header --------------------->
 * +-----------+-----------+-----+-----------+----------+------+
 * | offset[0] | offset[1] | ... | offset[n] | fragment | body |
 * +-----------+-----------+-----+-----------+----------+------+
 * <---- 4 ---->                             <--- 4 ---->
 */

typedef struct SORT_REC SORT_REC;
typedef struct SUBKEY_INFO SUBKEY_INFO;
typedef struct SORTKEY_INFO SORTKEY_INFO;
typedef struct SORT_INFO SORT_INFO;

struct SORT_REC
{
  SORT_REC *next;		/* forward link for duplicate sort_key value */
  union
  {
    /* Bread crumbs back to the original tuple, so that we can go
       straight there after the keys have been sorted. */
    struct
    {
      INT32 pageid;		/* Page identifier */
      INT16 volid;		/* Volume identifier */
      INT16 offset;		/* offset in page */
      char body[1];		/* sort_key body start position */
    } original;

    /*
     * The offset vector.  A value of zero for an entry means that the
     * corresponding column is null, and that there are no data bytes for
     * the column.  A non-zero entry is interpreted as the offset from
     * the *start* of the SORT_REC to the data bytes for that column.
     */
    int offset[1];
  } s;
};

struct SUBKEY_INFO
{
  /* The actual column number in the list file tuple. */
  int col;

  /*
   * The permuted column number, so that we can accurately reconstitute
   * records even when the order of the sort keys differs from the
   * order of the fields in the reconstituted tuple.
   *
   *  subkey_info[i]
   *
   * is the key info for the i'th field of the sort record, while
   *
   *  subkey_info[subkey_info[i].permuted_col]
   *
   * is the key info for the i'th field of the output record.
   */
  int permuted_col;

  TP_DOMAIN *col_dom;

  int (*sort_f) (void *tplp1, void *tplp2,
		 TP_DOMAIN * dom, int do_reverse,
		 int do_coercion, int total_order, int *start_col);

  /*
   * Non-zero iff the sort on this column is descending.  Factoring
   * this decision out of the actual sort function allows to use only
   * one of those guys, at no particularly great cost in performance,
   * and a big win in maintainability.
   */
  int is_desc;
};

struct SORTKEY_INFO
{
  int nkeys;			/* The number of columns in use today. */
  int use_original;		/* False iff the sort keys consist of all of
				   the input record fields, i.e., if we'll 
				   reconstruct the input records from the keys
				   rather than look them up again in the
				   original file. */
  SUBKEY_INFO *key;		/* Points to `default_keys' if `nkeys' <= 8;
				   otherwise it points to malloc'ed space. */
  SUBKEY_INFO default_keys[8];	/* Default storage; this ought to work for
				   most cases. */
};

struct SORT_INFO
{
  SORTKEY_INFO key_info;	/* All of the interesting key information. */
  QFILE_SORT_SCAN_ID *s_id;	/* A SCAN_ID for the input list file.  This is
				   stateful, and records the current location
				   of the scan between calls to
				   ls_sort_get_next(). */
  QFILE_LIST_ID *output_file;	/* The name of the output file.  This is where
				   ls_sort_put_next_*() deposits its stuff. */
  RECDES output_recdes;		/* A working buffer for output of tuples; used
				   only when we're using
				   ls_sort_put_next_short() as the output
				   function. */
  void *extra_arg;		/* extra information supplied by the caller */
};

extern int sort_listfile (THREAD_ENTRY * thread_p, INT16 volid,
			  int est_inp_pg_cnt, SORT_GET_FUNC * get_fn,
			  void *get_arg, SORT_PUT_FUNC * put_fn,
			  void *put_arg, SORT_CMP_FUNC * cmp_fn,
			  void *cmp_arg, SORT_DUP_OPTION option);
#endif /* _EXTERNAL_SORT_H_ */
