/*
 * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 */

/*
 * network_cl.c - client side support functions.
 */

#ident "$Id$"

#include "config.h"

#include <stdio.h>
#include <string.h>

/* for performance metering */
#if !defined(WINDOWS)
#include <sys/time.h>
#include <sys/resource.h>
#endif /* !WINDDOWS */

#include "network.h"
#include "network_interface_cl.h"
#include "chartype.h"
#include "connection_cl.h"
#include "server_interface.h"
#include "memory_alloc.h"
#include "databases_file.h"
#include "error_manager.h"
#include "system_parameter.h"
#include "boot_cl.h"
#include "xasl_support.h"
#include "query_method.h"
#include "release_string.h"
#include "log_comm.h"
#include "file_io.h"
#include "locator.h"
#include "db.h"
#include "client_support.h"
#include "perf_monitor.h"
#include "log_writer.h"

/*
 * To check for errors from the comm system. Note that if we get any error
 * other than RECORD_TRUNCATED or CANT_ALLOC_BUFFER, we will call it a
 * SERVER_CRASHED error.  Also note that CANT_ALLOC_BUFFER allows the
 * calling function to continue whereas other errors disconnect and escape
 * the function.
 */

#define SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS(err, rc, num_packets) \
  set_alloc_err_and_read_expected_packets((err), (rc), (num_packets), \
					  __FILE__, __LINE__)

#define COMPARE_SIZE_AND_BUFFER(replysize, size, replybuf, buf)       \
  compare_size_and_buffer((replysize), (size), (replybuf), (buf),     \
			  __FILE__, __LINE__)

/*
 * Add instrumentation to the client side to get histogram of network
 * requests
 */

struct net_request_buffer
{
  const char *name;
  int request_count;
  int total_size_sent;
  int total_size_received;
  int elapsed_time;
};
static struct net_request_buffer net_Req_buffer[NET_SERVER_REQUEST_END];

static int net_Histo_setup = 0;
static int net_Histo_setup_mnt = 0;
static int net_Histo_call_count = 0;
static int net_Histo_last_call_time = 0;
static int net_Histo_total_server_time = 0;

#if defined(CS_MODE)
unsigned short method_request_id;
#endif /* CS_MODE */

/* Contains the name of the current sever host machine.  */
static char net_Server_host[MAX_SERVER_HOST_NAME] = { 0 };

/* Contains the name of the current server name. */
static char net_Server_name[MAX_SERVER_NAME] = { 0 };

#if defined(CS_MODE)
static QUERY_ID save_query_id = NULL_QUERY_ID;
#endif /* CS_MODE */


static void return_error_to_server (char *host, unsigned int eid);
static void record_server_capabilities (int server_capabilities);
static void set_alloc_err_and_read_expected_packets (int *err, int rc,
						     int num_packets,
						     const char *file,
						     const int line);
static int compare_size_and_buffer (int *replysize, int size, char **replybuf,
				    char *buf, const char *file,
				    const int line);
static bool net_check_client_server_compatibility (const char *server_release,
						   const char
						   *client_release);
static int net_client_request_internal (bool send_by_oob, int request,
					char *argbuf, int argsize,
					char *replybuf, int replysize,
					char *databuf, int datasize,
					char *replydata, int replydatasize);
static int net_client_request_buffer (unsigned int rc, char **buf_ptr,
				      int expected_size);

static int set_server_error (int error);

/*
 * Shouldn't know about db_Connect_status at this level, must set this
 * to disable all db_ functions
 */

/*
 * set_server_error -
 *
 * return:
 *   error(in):
 *
 * Note:
 */

static int
set_server_error (int error)
{
  int server_error;

  switch (error)
    {
    case CANT_ALLOC_BUFFER:
      server_error = ER_NET_CANT_ALLOC_BUFFER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
      break;
    case RECORD_TRUNCATED:
      server_error = ER_NET_DATA_TRUNCATED;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
      break;
    case REQUEST_REFUSED:
      server_error = er_errid ();
      break;
    case SERVER_ABORTED:
      server_error = er_errid ();
      /* those errors are generated by the net_server_request()
       * so that do not fall to server crash handling */
      if (server_error == ER_DB_NO_MODIFICATIONS
	  || server_error == ER_AU_DBA_ONLY)
	{
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
	  return (server_error);
	}
    default:
      server_error = ER_NET_SERVER_CRASHED;
      er_set_with_oserror (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
      break;
    }
  er_log_debug (ARG_FILE_LINE, "set_server_error(%d) server_error %d\n",
		error, server_error);

  db_Connect_status = DB_CONNECTION_STATUS_NOT_CONNECTED;

  if (net_Server_name[0] != '\0')
    {
      net_Server_name[0] = '\0';
      net_Server_host[0] = '\0';
      boot_server_die_or_changed ();
    }

  return (server_error);
}

/*
 * return_error_to_server -
 *
 * return:
 *
 *   host(in):
 *   eid(in):
 *
 * Note:
 */
static void
return_error_to_server (char *host, unsigned int eid)
{
  void *area;
  char buffer[1024];
  int length = 1024;

  area = er_get_area_error (buffer, &length);
  if (area != NULL)
    {
      css_send_error_to_server (host, eid, (char *) area, length);
    }
}

/*
 * record_server_capabilities -
 *
 * return:
 *
 *   server_capabilities(in):
 *
 * Note:
 */
static void
record_server_capabilities (int server_capabilities)
{
  if (server_capabilities & NET_INTERRUPT_ENABLED_CAP)
    {
      net_Interrupt_enabled = 1;
    }
  else
    {
      net_Interrupt_enabled = 0;
    }
}

/*
 * set_alloc_err_and_read_expected_packets -
 *
 * return:
 *
 *   err(in):
 *   rc(in):
 *   num_packets(in):
 *   file(in):
 *   line(in):
 *
 * Note:
 *    Allocation failures are recorded and any outstanding data packets
 *    will try to be read.  Called by macro of the same name.
 */
static void
set_alloc_err_and_read_expected_packets (int *err, int rc, int num_packets,
					 const char *file, const int line)
{
  char *reply = NULL;
  int i, size = 0;

  /* don't set error if there already is one */
  if (!(*err))
    {
      *err = ER_NET_CANT_ALLOC_BUFFER;
      er_set (ER_ERROR_SEVERITY, file, line, *err, 0);
    }
  for (i = 0; i < (num_packets); i++)
    {
      css_receive_data_from_server ((rc), &reply, &size);
      if (reply != NULL)
	{
	  free_and_init (reply);
	}
    }
}

/*
 * compare_size_and_buffer -
 *
 * return:
 *
 *   replysize(in):
 *   size(in):
 *   replybuf(in):
 *   buf(in):
 *   file(in):
 *   line(in):
 *
 * Note:
 *    Compares sizes and buffers that have been queued with the actual
 *    received values after a data read.  Called by macro of the same name.
 */
static int
compare_size_and_buffer (int *replysize, int size, char **replybuf, char *buf,
			 const char *file, const int line)
{
  int err = NO_ERROR;

  if (size != *replysize)
    {
      err = ER_NET_DATASIZE_MISMATCH;
      er_set (ER_ERROR_SEVERITY, file, line, err, 2, *replysize, size);
      *replysize = size;
    }
  if (buf != *replybuf)
    {
      err = ER_NET_UNUSED_BUFFER;
      er_set (ER_ERROR_SEVERITY, file, line, err, 0);
      /* free it ? */
      *replybuf = buf;
    }
  return err;
}

/*
 * net_check_client_server_compatibility -
 *
 * return: true if compatible
 *
 *   server_release(in):
 *   client_release(in):
 *
 * Note:
 *    Compare the release strings from the server and client to
 *    determine compatibility.
 *
 *    We considered whether or not to create an additional
 *    "protocol" version string that must be incremented every time
 *    someone makes a change that would affect the communications protocol.
 *
 *    We decided that the developer who realizes that their change would
 *    have an impact is the developer who will make sure their change is
 *    backwardly compatible.  An un-incremented protocol string does no
 *    good to detect unwitting protocol changes.
 *
 */
static bool
net_check_client_server_compatibility (const char *server_release,
				       const char *client_release)
{
  bool compatible = false;

  /* Release strings should be in the form: "<major>.<minor>[.<bugfix>]".
   * The server and client must have the same release.
   */
  if (server_release && client_release
      && rel_compare (server_release, client_release) == 0)
    {
      compatible = true;
    }
  return compatible;
}

/*
 * histo_setup_names -
 *
 * return:
 *
 * Note:
 */
static void
histo_setup_names (void)
{
  unsigned int i;

  for (i = 0; i < DIM (net_Req_buffer); i++)
    {
      net_Req_buffer[i].name = "";
      net_Req_buffer[i].request_count = 0;
      net_Req_buffer[i].total_size_sent = 0;
      net_Req_buffer[i].total_size_received = 0;
      net_Req_buffer[i].elapsed_time = 0;
    }

  net_Req_buffer[NET_SERVER_BO_INIT_SERVER].name =
    "NET_SERVER_BO_INIT_SERVER";
  net_Req_buffer[NET_SERVER_BO_REGISTER_CLIENT].name =
    "NET_SERVER_BO_REGISTER_CLIENT";
  net_Req_buffer[NET_SERVER_BO_UNREGISTER_CLIENT].name =
    "NET_SERVER_BO_UNREGISTER_CLIENT";
  net_Req_buffer[NET_SERVER_BO_BACKUP].name = "NET_SERVER_BO_BACKUP";
  net_Req_buffer[NET_SERVER_BO_ADD_VOLEXT].name = "NET_SERVER_BO_ADD_VOLEXT";
  net_Req_buffer[NET_SERVER_BO_CHECK_DBCONSISTENCY].name =
    "NET_SERVER_BO_CHECK_DBCONSISTENCY";
  net_Req_buffer[NET_SERVER_BO_FIND_NPERM_VOLS].name =
    "NET_SERVER_BO_FIND_NPERM_VOLS";
  net_Req_buffer[NET_SERVER_BO_FIND_NTEMP_VOLS].name =
    "NET_SERVER_BO_FIND_NTEMP_VOLS";
  net_Req_buffer[NET_SERVER_BO_FIND_LAST_TEMP].name =
    "NET_SERVER_BO_FIND_LAST_TEMP";
  net_Req_buffer[NET_SERVER_BO_CHANGE_HA_MODE].name =
    "NET_SERVER_BO_CHANGE_HA_MODE";

  net_Req_buffer[NET_SERVER_TM_SERVER_COMMIT].name =
    "NET_SERVER_TM_SERVER_COMMIT";
  net_Req_buffer[NET_SERVER_TM_SERVER_ABORT].name =
    "NET_SERVER_TM_SERVER_ABORT";
  net_Req_buffer[NET_SERVER_TM_SERVER_START_TOPOP].name =
    "NET_SERVER_TM_SERVER_START_TOPOP";
  net_Req_buffer[NET_SERVER_TM_SERVER_END_TOPOP].name =
    "NET_SERVER_TM_SERVER_END_TOPOP";
  net_Req_buffer[NET_SERVER_TM_SERVER_SAVEPOINT].name =
    "NET_SERVER_TM_SERVER_SAVEPOINT";
  net_Req_buffer[NET_SERVER_TM_SERVER_PARTIAL_ABORT].name =
    "NET_SERVER_TM_SERVER_PARTIAL_ABORT";
  net_Req_buffer[NET_SERVER_TM_SERVER_HAS_UPDATED].name =
    "NET_SERVER_TM_SERVER_HAS_UPDATED";
  net_Req_buffer[NET_SERVER_TM_SERVER_ISACTIVE_AND_HAS_UPDATED].name =
    "NET_SERVER_TM_NET_SERVER_ISACTIVE_AND_HAS_UPDATED";
  net_Req_buffer[NET_SERVER_TM_ISBLOCKED].name = "NET_SERVER_TM_ISBLOCKED";
  net_Req_buffer[NET_SERVER_TM_WAIT_SERVER_ACTIVE_TRANS].name =
    "NET_SERVER_TM_WAIT_SERVER_ACTIVE_TRANS";
  net_Req_buffer[NET_SERVER_TM_SERVER_GET_GTRINFO].name =
    "NET_SERVER_TM_SERVER_GET_GTRINFO";
  net_Req_buffer[NET_SERVER_TM_SERVER_SET_GTRINFO].name =
    "NET_SERVER_TM_SERVER_SET_GTRINFO";
  net_Req_buffer[NET_SERVER_TM_SERVER_2PC_START].name =
    "NET_SERVER_TM_SERVER_2PC_START";
  net_Req_buffer[NET_SERVER_TM_SERVER_2PC_PREPARE].name =
    "NET_SERVER_TM_NET_SERVER_2PC_PREPARE";
  net_Req_buffer[NET_SERVER_TM_SERVER_2PC_RECOVERY_PREPARED].name =
    "NET_SERVER_TM_NET_SERVER_2PC_RECOVERY_PREPARED";
  net_Req_buffer[NET_SERVER_TM_SERVER_2PC_ATTACH_GT].name =
    "NET_SERVER_TM_SERVER_2PC_ATTACH_GT";
  net_Req_buffer[NET_SERVER_TM_SERVER_2PC_PREPARE_GT].name =
    "NET_SERVER_TM_NET_SERVER_2PC_PREPARE_GT";
  net_Req_buffer[NET_SERVER_TM_LOCAL_TRANSACTION_ID].name =
    "NET_SERVER_TM_LOCAL_TRANSACTION_ID";

  net_Req_buffer[NET_SERVER_LC_FETCH].name = "NET_SERVER_LC_FETCH";
  net_Req_buffer[NET_SERVER_LC_FETCHALL].name = "NET_SERVER_LC_FETCHALL";
  net_Req_buffer[NET_SERVER_LC_FETCH_LOCKSET].name =
    "NET_SERVER_LC_FETCH_LOCKSET";
  net_Req_buffer[NET_SERVER_LC_FETCH_ALLREFS_LOCKSET].name =
    "NET_SERVER_LC_FETCH_ALLREFS_LOCKSET";
  net_Req_buffer[NET_SERVER_LC_GET_CLASS].name = "NET_SERVER_LC_GET_CLASS";
  net_Req_buffer[NET_SERVER_LC_FIND_CLASSOID].name =
    "NET_SERVER_LC_FIND_CLASSOID";
  net_Req_buffer[NET_SERVER_LC_DOESEXIST].name = "NET_SERVER_LC_DOESEXIST";
  net_Req_buffer[NET_SERVER_LC_FORCE].name = "NET_SERVER_LC_FORCE";
  net_Req_buffer[NET_SERVER_LC_RESERVE_CLASSNAME].name =
    "NET_SERVER_LC_RESERVE_CLASSNAME";
  net_Req_buffer[NET_SERVER_LC_DELETE_CLASSNAME].name =
    "NET_SERVER_LC_DELETE_CLASSNAME";
  net_Req_buffer[NET_SERVER_LC_RENAME_CLASSNAME].name =
    "NET_SERVER_LC_RENAME_CLASSNAME";
  net_Req_buffer[NET_SERVER_LC_ASSIGN_OID].name = "NET_SERVER_LC_ASSIGN_OID";
  net_Req_buffer[NET_SERVER_LC_NOTIFY_ISOLATION_INCONS].name =
    "NET_SERVER_LC_NOTIFY_ISOLATION_INCONS";
  net_Req_buffer[NET_SERVER_LC_FIND_LOCKHINT_CLASSOIDS].name =
    "NET_SERVER_LC_FIND_LOCKHINT_CLASSOIDS";
  net_Req_buffer[NET_SERVER_LC_FETCH_LOCKHINT_CLASSES].name =
    "NET_SERVER_LC_FETCH_LOCKHINT_CLASSES";
  net_Req_buffer[NET_SERVER_LC_ASSIGN_OID_BATCH].name =
    "NET_SERVER_LC_ASSIGN_OID_BATCH";
  net_Req_buffer[NET_SERVER_LC_BUILD_FK_OBJECT_CACHE].name =
    "NET_SERVER_LC_BUILD_FK_OBJECT_CACHE";
  net_Req_buffer[NET_SERVER_LC_REM_CLASS_FROM_INDEX].name =
    "NET_SERVER_LC_REM_CLASS_FROM_INDEX";

  net_Req_buffer[NET_SERVER_HEAP_CREATE].name = "NET_SERVER_HEAP_CREATE";
  net_Req_buffer[NET_SERVER_HEAP_DESTROY].name = "NET_SERVER_HEAP_DESTROY";
  net_Req_buffer[NET_SERVER_HEAP_DESTROY_WHEN_NEW].name =
    "NET_SERVER_HEAP_DESTROY_WHEN_NEW";
  net_Req_buffer[NET_SERVER_HEAP_GET_CLASS_NOBJS_AND_NPAGES].name =
    "NET_SERVER_HEAP_GET_CLASS_NOBJS_AND_NPAGES";
  net_Req_buffer[NET_SERVER_HEAP_HAS_INSTANCE].name =
    "NET_SERVER_HEAP_HAS_INSTANCE";

  net_Req_buffer[NET_SERVER_LARGEOBJMGR_CREATE].name =
    "NET_SERVER_LARGEOBJMGR_CREATE";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_READ].name =
    "NET_SERVER_LARGEOBJMGR_READ";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_WRITE].name =
    "NET_SERVER_LARGEOBJMGR_WRITE";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_INSERT].name =
    "NET_SERVER_LARGEOBJMGR_INSERT";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_DESTROY].name =
    "NET_SERVER_LARGEOBJMGR_DESTROY";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_DELETE].name =
    "NET_SERVER_LARGEOBJMGR_DELETE";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_APPEND].name =
    "NET_SERVER_LARGEOBJMGR_APPEND";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_TRUNCATE].name =
    "NET_SERVER_LARGEOBJMGR_TRUNCATE";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_COMPRESS].name =
    "NET_SERVER_LARGEOBJMGR_COMPRESS";
  net_Req_buffer[NET_SERVER_LARGEOBJMGR_LENGTH].name =
    "NET_SERVER_LARGEOBJMGR_LENGTH";

  net_Req_buffer[NET_SERVER_LOG_RESET_WAITSECS].name =
    "NET_SERVER_LOG_RESET_WAITSECS";
  net_Req_buffer[NET_SERVER_LOG_RESET_ISOLATION].name =
    "NET_SERVER_LOG_RESET_ISOLATION";
  net_Req_buffer[NET_SERVER_LOG_SET_INTERRUPT].name =
    "NET_SERVER_LOG_SET_INTERRUPT";
  net_Req_buffer[NET_SERVER_LOG_CLIENT_UNDO].name =
    "NET_SERVER_LOG_CLIENT_UNDO";
  net_Req_buffer[NET_SERVER_LOG_CLIENT_POSTPONE].name =
    "NET_SERVER_LOG_CLIENT_POSTPONE";
  net_Req_buffer[NET_SERVER_LOG_HAS_FINISHED_CLIENT_POSTPONE].name =
    "NET_SERVER_LOG_HAS_FINISHED_CLIENT_POSTPONE";
  net_Req_buffer[NET_SERVER_LOG_HAS_FINISHED_CLIENT_UNDO].name =
    "NET_SERVER_LOG_HAS_FINISHED_CLIENT_UNDO";
  net_Req_buffer[NET_SERVER_LOG_CLIENT_GET_FIRST_POSTPONE].name =
    "NET_SERVER_LOG_CLIENT_GET_FIRST_POSTPONE";
  net_Req_buffer[NET_SERVER_LOG_CLIENT_GET_FIRST_UNDO].name =
    "NET_SERVER_LOG_CLIENT_GET_FIRST_UNDO";
  net_Req_buffer[NET_SERVER_LOG_CLIENT_GET_NEXT_POSTPONE].name =
    "NET_SERVER_LOG_CLIENT_GET_NEXT_POSTPONE";
  net_Req_buffer[NET_SERVER_LOG_CLIENT_GET_NEXT_UNDO].name =
    "NET_SERVER_LOG_CLIENT_GET_NEXT_UNDO";
  net_Req_buffer[NET_SERVER_LOG_CLIENT_UNKNOWN_STATE_ABORT_GET_FIRST_UNDO].
    name = "NET_SERVER_LOG_CLIENT_UNKNOWN_STATE_ABORT_GET_FIRST_UNDO";
  net_Req_buffer[NET_SERVER_LOG_DUMP_STAT].name = "NET_SERVER_LOG_DUMP_STAT";
  net_Req_buffer[NET_SERVER_LOG_GETPACK_TRANTB].name =
    "NET_SERVER_LOG_GETPACK_TRANTB";

  net_Req_buffer[NET_SERVER_LK_DUMP].name = "NET_SERVER_LK_DUMP";

  net_Req_buffer[NET_SERVER_BTREE_ADDINDEX].name =
    "NET_SERVER_BTREE_ADDINDEX";
  net_Req_buffer[NET_SERVER_BTREE_DELINDEX].name =
    "NET_SERVER_BTREE_DELINDEX";
  net_Req_buffer[NET_SERVER_BTREE_LOADINDEX].name =
    "NET_SERVER_BTREE_LOADINDEX";
  net_Req_buffer[NET_SERVER_BTREE_FIND_UNIQUE].name =
    "NET_SERVER_BTREE_FIND_UNIQUE";
  net_Req_buffer[NET_SERVER_BTREE_CLASS_UNIQUE_TEST].name =
    "NET_SERVER_BTREE_CLASS_UNIQUE_TEST";
  net_Req_buffer[NET_SERVER_BTREE_GET_STATISTICS].name =
    "NET_SERVER_BTREE_GET_STATISTICS";

  net_Req_buffer[NET_SERVER_DISK_TOTALPGS].name = "NET_SERVER_DISK_TOTALPGS";
  net_Req_buffer[NET_SERVER_DISK_FREEPGS].name = "NET_SERVER_DISK_FREEPGS";
  net_Req_buffer[NET_SERVER_DISK_REMARKS].name = "NET_SERVER_DISK_REMARKS";
  net_Req_buffer[NET_SERVER_DISK_PURPOSE].name = "NET_SERVER_DISK_PURPOSE";
  net_Req_buffer[NET_SERVER_DISK_PURPOSE_TOTALPGS_AND_FREEPGS].name =
    "NET_SERVER_DISK_PURPOSE_TOTALPGS_AND_FREEPGS";
  net_Req_buffer[NET_SERVER_DISK_VLABEL].name = "NET_SERVER_DISK_VLABEL";

  net_Req_buffer[NET_SERVER_QST_SERVER_GET_STATISTICS].name =
    "NET_SERVER_QST_SERVER_GET_STATISTICS";
  net_Req_buffer[NET_SERVER_QST_UPDATE_CLASS_STATISTICS].name =
    "NET_SERVER_QST_UPDATE_CLASS_STATISTICS";
  net_Req_buffer[NET_SERVER_QST_UPDATE_STATISTICS].name =
    "NET_SERVER_QST_UPDATE_STATISTICS";

  net_Req_buffer[NET_SERVER_QM_QUERY_PREPARE].name =
    "NET_SERVER_QM_QUERY_PREPARE";
  net_Req_buffer[NET_SERVER_QM_QUERY_EXECUTE].name =
    "NET_SERVER_QM_QUERY_EXECUTE";
  net_Req_buffer[NET_SERVER_QM_QUERY_PREPARE_AND_EXECUTE].name =
    "NET_SERVER_QM_QUERY_PREPARE_AND_EXECUTE";
  net_Req_buffer[NET_SERVER_QM_QUERY_END].name = "NET_SERVER_QM_QUERY_END";
  net_Req_buffer[NET_SERVER_QM_QUERY_DROP_PLAN].name =
    "NET_SERVER_QM_QUERY_DROP_PLAN";
  net_Req_buffer[NET_SERVER_QM_QUERY_DROP_ALL_PLANS].name =
    "NET_SERVER_QM_QUERY_DROP_ALL_PLANS";
  net_Req_buffer[NET_SERVER_QM_QUERY_SYNC].name = "NET_SERVER_QM_QUERY_SYNC";
  net_Req_buffer[NET_SERVER_QM_GET_QUERY_INFO].name =
    "NET_SERVER_QM_GET_QUERY_INFO";
  net_Req_buffer[NET_SERVER_QM_QUERY_EXECUTE_ASYNC].name =
    "NET_SERVER_QM_QUERY_EXECUTE_ASYNC";
  net_Req_buffer[NET_SERVER_QM_QUERY_PREPARE_AND_EXECUTE_ASYNC].name =
    "NET_SERVER_QM_QUERY_PREPARE_AND_EXECUTE_ASYNC";
  net_Req_buffer[NET_SERVER_QM_QUERY_DUMP_PLANS].name =
    "NET_SERVER_QM_QUERY_DUMP_PLANS";
  net_Req_buffer[NET_SERVER_QM_QUERY_DUMP_CACHE].name =
    "NET_SERVER_QM_QUERY_DUMP_CACHE";

  net_Req_buffer[NET_SERVER_LS_GET_LIST_FILE_PAGE].name =
    "NET_SERVER_LS_GET_LIST_FILE_PAGE";

  net_Req_buffer[NET_SERVER_MNT_SERVER_START_STATS].name =
    "NET_SERVER_MNT_SERVER_START_STATS";
  net_Req_buffer[NET_SERVER_MNT_SERVER_STOP_STATS].name =
    "NET_SERVER_MNT_SERVER_STOP_STATS";
  net_Req_buffer[NET_SERVER_MNT_SERVER_RESET_STATS].name =
    "NET_SERVER_MNT_SERVER_RESET_STATS";
  net_Req_buffer[NET_SERVER_MNT_SERVER_COPY_STATS].name =
    "NET_SERVER_MNT_SERVER_COPY_STATS";

  net_Req_buffer[NET_SERVER_CT_CAN_ACCEPT_NEW_REPR].name =
    "NET_SERVER_CT_CAN_ACCEPT_NEW_REPR";

  net_Req_buffer[NET_SERVER_CSS_KILL_TRANSACTION].name =
    "NET_SERVER_CSS_KILL_TRANSACTION";

  net_Req_buffer[NET_SERVER_QPROC_GET_SYS_TIMESTAMP].name =
    "NET_SERVER_QPROC_GET_SYS_TIMESTAMP";
  net_Req_buffer[NET_SERVER_QPROC_GET_CURRENT_VALUE].name =
    "NET_SERVER_QPROC_GET_CURRENT_VALUE";
  net_Req_buffer[NET_SERVER_QPROC_GET_NEXT_VALUE].name =
    "NET_SERVER_QPROC_GET_NEXT_VALUE";
  net_Req_buffer[NET_SERVER_QPROC_GET_SERVER_INFO].name =
    "NET_SERVER_QPROC_GET_SERVER_INFO";

  net_Req_buffer[NET_SERVER_PRM_SET_PARAMETERS].name =
    "NET_SERVER_PRM_SET_PARAMETERS";
  net_Req_buffer[NET_SERVER_PRM_GET_PARAMETERS].name =
    "NET_SERVER_PRM_GET_PARAMETERS";

  net_Req_buffer[NET_SERVER_JSP_GET_SERVER_PORT].name =
    "NET_SERVER_JSP_GET_SERVER_PORT";

  net_Req_buffer[NET_SERVER_REPL_INFO].name = "NET_SERVER_REPL_INFO";
  net_Req_buffer[NET_SERVER_REPL_LOG_GET_APPEND_LSA].name =
    "NET_SERVER_REPL_LOG_GET_APPEND_LSA";

  net_Req_buffer[NET_SERVER_LOGWR_GET_LOG_PAGES].name =
    "NET_SERVER_LOGWR_GET_LOG_PAGES";

  net_Req_buffer[NET_SERVER_TEST_PERFORMANCE].name =
    "NET_SERVER_TEST_PERFORMANCE";

  net_Req_buffer[NET_SERVER_SHUTDOWN].name = "NET_SERVER_SHUTDOWN";
}

/*
 * histo_is_supported -
 *
 * return:
 *
 * Note:
 */
bool
histo_is_supported (void)
{
  /* introduce PRM_... */
  return PRM_ENABLE_HISTO;
}

/*
 * histo_clear -
 *
 * return:
 *
 * NOTE:
 */
void
histo_clear (void)
{
  unsigned int i;

  if (net_Histo_setup_mnt)
    {
      mnt_reset_stats ();
    }

  net_Histo_call_count = 0;
  net_Histo_last_call_time = 0;
  net_Histo_total_server_time = 0;
  for (i = 0; i < DIM (net_Req_buffer); i++)
    {
      net_Req_buffer[i].request_count = 0;
      net_Req_buffer[i].total_size_sent = 0;
      net_Req_buffer[i].total_size_received = 0;
      net_Req_buffer[i].elapsed_time = 0;
    }
}

/*
 * histo_print -
 *
 * return:
 *
 * Note:
 */
void
histo_print (void)
{
  unsigned int i;
  int found = 0, total_requests = 0, total_size_sent = 0;
  int total_size_received = 0;
  float server_time, total_server_time = 0;
  float avg_response_time, avg_client_time;

  fprintf (stdout, "\nHistogram of client requests:\n");
  fprintf (stdout, "%-31s %6s  %10s %10s , %10s \n",
	   "Name", "Rcount", "Sent size", "Recv size", "Server time");
  for (i = 0; i < DIM (net_Req_buffer); i++)
    {
      if (net_Req_buffer[i].request_count)
	{
	  found = 1;
	  server_time = ((float) net_Req_buffer[i].elapsed_time / 1000000 /
			 (float) (net_Req_buffer[i].request_count));
	  fprintf (stdout, "%-29s %6d X %10d+%10d b, %10.6f s\n",
		   net_Req_buffer[i].name, net_Req_buffer[i].request_count,
		   net_Req_buffer[i].total_size_sent,
		   net_Req_buffer[i].total_size_received, server_time);
	  total_requests += net_Req_buffer[i].request_count;
	  total_size_sent += net_Req_buffer[i].total_size_sent;
	  total_size_received += net_Req_buffer[i].total_size_received;
	  total_server_time +=
	    (server_time * net_Req_buffer[i].request_count);
	}
    }
  if (!found)
    {
      fprintf (stdout, " No server requests made\n");
    }
  else
    {
      fprintf (stdout,
	       "-------------------------------------------------------------"
	       "--------------\n");
      fprintf (stdout,
	       "Totals:                       %6d X %10d+%10d b  "
	       "%10.6f s\n", total_requests, total_size_sent,
	       total_size_received, total_server_time);
      avg_response_time = total_server_time / total_requests;
      avg_client_time = 0.0;
      fprintf (stdout, "\n Average server response time = %6.6f secs \n"
	       " Average time between client requests = %6.6f secs \n",
	       avg_response_time, avg_client_time);
    }
  if (net_Histo_setup_mnt)
    {
      mnt_print_stats (NULL);
    }
}

/*
 * histo_start -
 *
 * return: NO_ERROR or ER_FAILED
 *
 * Note:
 */
int
histo_start (void)
{
  if (net_Histo_setup == 0)
    {
      histo_clear ();
      histo_setup_names ();
      net_Histo_setup = 1;
    }
  if (net_Histo_setup_mnt == 0)
    {
      if (mnt_start_stats () != NO_ERROR)
	{
	  return ER_FAILED;
	}
      net_Histo_setup_mnt = 1;
    }
  return NO_ERROR;
}

/*
 * histo_stop -
 *
 * return: NO_ERROR or ER_FAILED
 *
 * Note:
 */
int
histo_stop (void)
{
  int err = NO_ERROR;

  if (net_Histo_setup_mnt == 1)
    {
      err = mnt_stop_stats ();
      net_Histo_setup_mnt = 0;
    }
  if (net_Histo_setup == 1)
    {
      net_Histo_setup = 0;
    }
  return err;
}

/*
 * histo_add_entry -
 *
 * return:
 *
 *   request(in):
 *   data_sent(in):
 *
 * Note:
 */
void
histo_add_entry (int request, int data_sent)
{
#if !defined(WINDOWS)
  struct timeval tp;
#endif /* WINDOWS */

  if (request <= NET_SERVER_REQUEST_START
      || request >= NET_SERVER_REQUEST_END)
    {
      return;
    }

  net_Req_buffer[request].request_count++;
  net_Req_buffer[request].total_size_sent += data_sent;
#if !defined(WINDOWS)
  if (gettimeofday (&tp, NULL) == 0)
    {
      net_Histo_last_call_time = tp.tv_sec * 1000000 + tp.tv_usec;
    }
#endif /* !WINDOWS */
  net_Histo_call_count++;
}

/*
 * histo_request_finished -
 *
 * return:
 *
 *   request(in):
 *   data_received(in):
 *
 * Note:
 */
void
histo_request_finished (int request, int data_received)
{
#if !defined(WINDOWS)
  struct timeval tp;
  int current_time;
#endif /* !WINDOWS */

  net_Req_buffer[request].total_size_received += data_received;

#if !defined(WINDOWS)
  if (gettimeofday (&tp, NULL) == 0)
    {
      current_time = tp.tv_sec * 1000000 + tp.tv_usec;
      net_Req_buffer[request].elapsed_time +=
	(current_time - net_Histo_last_call_time);
      net_Histo_total_server_time = (current_time - net_Histo_last_call_time);
    }
#endif /* !WINDOWS */
}

/*
 * histo_total_interfaces -
 *
 * return:
 *
 * Note:
 */
int
histo_total_interfaces (void)
{
  return (DIM (net_Req_buffer));
}

/*
 * histo_hit -
 *
 * return:
 *
 *   index(in):
 *
 * Note:
 */
int
histo_hit (int index)
{
  return (net_Req_buffer[index].request_count);
}

/*
 * histo_get_name -
 *
 * return:
 *
 *   index(in):
 *
 * Note:
 */
const char *
histo_get_name (int index)
{
  if (net_Req_buffer[index].name == NULL
      || net_Req_buffer[index].name[0] == '\0')
    {
      return NULL;
    }
  else
    {
      return (net_Req_buffer[index].name);
    }
}


/*
 * net_client_req_no_reply_via_oob -
 *
 * return:
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *
 * Note: same as net_client_request_no_reply, but sends the message via oob
 *       channel
 */
int
net_client_req_no_reply_via_oob (int request, char *argbuf, int argsize)
{
  unsigned int rc;
  int error;

  error = NO_ERROR;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }

  if (net_Histo_setup)
    {
      histo_add_entry (request, argsize);
    }

  rc = css_send_oob_to_server_with_buffer (net_Server_host, request, argbuf,
					   argsize);
  if (rc == 0)
    {
      error = css_Errno;
      return set_server_error (error);
    }

  return error;
}

/*
 * net_client_get_server_host () - the name of the current sever host machine
 *
 * return: string
 */
char *
net_client_get_server_host (void)
{
  return net_Server_host;
}

/*
 * net_client_request_internal -
 *
 * return: error status
 *
 *   send_by_oob(in): flag, if true, to send request via oob mesasge.
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf(in): data buffer to send (large)
 *   datasize(in): size of data buffer
 *   replydata(in): receive data buffer (large)
 *   replydatasize(in): size of expected reply data
 *
 * Note: This is one of two functions that is called to perform a server
 *       request.  All network interface routines will call either this
 *       functino or net_client_request2.
 */
static int
net_client_request_internal (bool send_by_oob, int request, char *argbuf,
			     int argsize, char *replybuf, int replysize,
			     char *databuf, int datasize, char *replydata,
			     int replydatasize)
{
  unsigned int rc;
  int size;
  int error;
  char *reply;

  error = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_add_entry (request, argsize + datasize);
    }
#endif /* HISTO */

  if (send_by_oob)
    {
      rc = css_send_oob_to_server_with_buffer (net_Server_host,
					       request, argbuf, argsize);
      if ((rc != 0) && (databuf != NULL))
	{
	  rc = css_send_data_to_server (net_Server_host,
					rc, databuf, datasize);
	}
    }
  else
    {
      rc = css_send_req_to_server (net_Server_host,
				   request, argbuf, argsize,
				   databuf, datasize, replybuf, replysize);
    }

  if (rc == 0)
    {
      error = css_Errno;
      return set_server_error (error);
    }

  if (rc)
    {
      if (replydata != NULL)
	{
	  css_queue_receive_data_buffer (rc, replydata, replydatasize);
	}
      error = css_receive_data_from_server (rc, &reply, &size);
      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
      else
	{
	  error = COMPARE_SIZE_AND_BUFFER (&replysize, size,
					   &replybuf, reply);
	}

      if (replydata != NULL)
	{
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
	  else
	    {
	      error = COMPARE_SIZE_AND_BUFFER (&replydatasize, size,
					       &replydata, reply);
	    }
	}
    }
#if defined(HISTO)
  if (Setup)
    {
      histo_request_finished (request, replysize + replydatasize);
    }
#endif /* HISTO */
  return (error);
}

/*
 * net_client_request -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf(in): data buffer to send (large)
 *   datasize(in): size of data buffer
 *   replydata(in): receive data buffer (large)
 *   replydatasize(in): size of expected reply data
 *
 * Note: This is one of two functions that is called to perform a server
 *    request.  All network interface routines will call either this
 *    function or net_client_request2.
 */
int
net_client_request (int request, char *argbuf, int argsize, char *replybuf,
		    int replysize, char *databuf, int datasize,
		    char *replydata, int replydatasize)
{
  /*
   * if request is SERVER_QM_QUERY_END, delay to send the request until next
   * request.
   * if next request is SERVER_TM_SERVER_COMMIT or SERVER_TM_SERVER_ABORT,
   * do not send SERVER_QM_QUERY_END request to be kept, else send it before
   * sending next request.
   */
  if (request == NET_SERVER_QM_QUERY_END && save_query_id == NULL_QUERY_ID)
    {
      /* unpack query id and save it, and return success */
      (void) or_unpack_ptr (argbuf, &save_query_id);
      (void) or_pack_int (replybuf, (int) NO_ERROR);
      replydatasize = sizeof (int);
      return 0;
    }

  if (request == NET_SERVER_TM_SERVER_COMMIT
      || request == NET_SERVER_TM_SERVER_ABORT)
    {
      /* skip to send SERVER_QM_QUERY_END request */
      save_query_id = NULL_QUERY_ID;
    }
  else if (save_query_id != NULL_QUERY_ID)
    {
      int status = ER_FAILED;
      int req_error;
      OR_ALIGNED_BUF (OR_PTR_SIZE) a_request;
      char *requestbuf;
      OR_ALIGNED_BUF (OR_INT_SIZE) a_reply;
      char *reply;

      requestbuf = OR_ALIGNED_BUF_START (a_request);
      reply = OR_ALIGNED_BUF_START (a_reply);

      (void) or_pack_ptr (requestbuf, save_query_id);

      /* send SERVER_QM_QUERY_END request */
      req_error = net_client_request_internal (false, NET_SERVER_QM_QUERY_END,
					       requestbuf,
					       OR_ALIGNED_BUF_SIZE
					       (a_request), reply,
					       OR_ALIGNED_BUF_SIZE (a_reply),
					       NULL, 0, NULL, 0);
      if (!req_error)
	{
	  (void) or_unpack_int (reply, &status);
	}

      save_query_id = NULL_QUERY_ID;
#if 0				/* ignore result */
      return ((int) status);
#endif
    }

  return (net_client_request_internal (false, request,
				       argbuf, argsize,
				       replybuf, replysize,
				       databuf, datasize,
				       replydata, replydatasize));
}

/*
 * net_client_request_via_oob -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf(in): data buffer to send (large)
 *   datasize(in): size of data buffer
 *   replydata(in): receive data buffer (large)
 *   replydatasize(in): size of expected reply data
 *
 * Note: This is one of the functions called to send a request to the server.
 *    This request is sent via the out-of-band message interface which will
 *    cause an immediate interrupt on the server.
 */
int
net_client_request_via_oob (int request, char *argbuf, int argsize,
			    char *replybuf, int replysize, char *databuf,
			    int datasize, char *replydata, int replydatasize)
{
  return (net_client_request_internal (true, request,
				       argbuf, argsize,
				       replybuf, replysize,
				       databuf, datasize,
				       replydata, replydatasize));
}

/*
 * net_client_request_send_large_data -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf(in): data buffer to send (large)
 *   datasize(in): size of data buffer
 *   replydata(in): receive data buffer (large)
 *   replydatasize(in): size of expected reply data
 *
 * Note: This is one of two functions that is called to perform a server
 *    request.  All network interface routines will call either this
 *    function or net_client_request2.
 */
int
net_client_request_send_large_data (int request, char *argbuf, int argsize,
				    char *replybuf, int replysize,
				    char *databuf, FSIZE_T datasize,
				    char *replydata, int replydatasize)
{
  unsigned int rc;
  int size;
  int error;
  char *reply;

  error = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }

#if defined(HISTO)
  if (Setup)
    {
      histo_add_entry (request, argsize + datasize);
    }
#endif /* HISTO */

  rc = css_send_req_to_server_with_large_data (net_Server_host,
					       request, argbuf, argsize,
					       databuf, datasize, replybuf,
					       replysize);

  if (rc == 0)
    {
      error = css_Errno;
      return set_server_error (error);
    }

  if (rc)
    {
      if (replydata != NULL)
	{
	  css_queue_receive_data_buffer (rc, replydata, replydatasize);
	}
      error = css_receive_data_from_server (rc, &reply, &size);
      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
      else
	{
	  error = COMPARE_SIZE_AND_BUFFER (&replysize, size,
					   &replybuf, reply);
	}

      if (replydata != NULL)
	{
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
	  else
	    {
	      error = COMPARE_SIZE_AND_BUFFER (&replydatasize, size,
					       &replydata, reply);
	    }
	}
    }
#if defined(HISTO)
  if (Setup)
    {
      histo_request_finished (request, replysize + replydatasize);
    }
#endif /* HISTO */
  return (error);
}

/*
 * net_client_request_recv_large_data -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in):  byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf(in): data buffer to send (large)
 *   datasize(in): size of data buffer
 *   replydata(in): receive data buffer (large)
 *   replydatasize_ptr(in): size of expected reply data
 *
 * Note:
 */
int
net_client_request_recv_large_data (int request, char *argbuf, int argsize,
				    char *replybuf, int replysize,
				    char *databuf, int datasize,
				    char *replydata,
				    FSIZE_T * replydatasize_ptr)
{
  unsigned int rc;
  int size;
  int error;
  INT64 tmp_int64;
  ssize_t reply_datasize;
  int num_data;
  char *reply, *ptr, *packed_desc;
  int i, packed_desc_size;

  error = 0;
  *replydatasize_ptr = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
    }
  else
    {
#if defined(HISTO)
      if (Setup)
	{
	  histo_add_entry (request, argsize + datasize);
	}
#endif /* HISTO */
      rc = css_send_req_to_server (net_Server_host, request, argbuf,
				   argsize, databuf, datasize, replybuf,
				   replysize);
      if (rc == 0)
	{
	  return set_server_error (css_Errno);
	}

      error = css_receive_data_from_server (rc, &reply, &size);

      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
      else
	{
	  error = COMPARE_SIZE_AND_BUFFER (&replysize, size,
					   &replybuf, reply);
	}

      /* here we assume that the first integer in the reply is the length
         of the following data block */
      ptr = or_unpack_int64 (reply, &tmp_int64);
      reply_datasize = tmp_int64;
      ptr = or_unpack_int (ptr, &num_data);

      if (reply_datasize)
	{
	  for (i = 0; i < num_data; i++)
	    {
	      packed_desc_size = MIN ((int) reply_datasize, INT_MAX);

	      packed_desc = (char *) malloc (packed_desc_size);
	      if (packed_desc == NULL)
		{
		  return set_server_error (CANT_ALLOC_BUFFER);
		}
	      css_queue_receive_data_buffer (rc, packed_desc,
					     packed_desc_size);
	      error = css_receive_data_from_server (rc, &reply, &size);
	      if (error != NO_ERROR)
		{
		  free_and_init (packed_desc);
		  return set_server_error (error);
		}
	      else
		{
		  memcpy (replydata, reply, size);
		  free_and_init (packed_desc);
		}
	      *replydatasize_ptr += size;
	      reply_datasize -= size;
	      replydata += size;
	    }
	}

#if defined(HISTO)
      if (Setup)
	{
	  histo_request_finished (request, replysize + *replydatasize_ptr);
	}
#endif /* HISTO */
    }
  return (error);
}

/*
 * net_client_request2 -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf(in): data buffer to send (large)
 *   datasize(in): size of data buffer
 *   replydata_ptr(in): receive data buffer (large)
 *   replydatasize_ptr(in):  size of expected reply data
 *
 * Note: This is one of two functions that is called to perform a server
 *    request.  All network interface routines will call either this
 *    functino or net_client_request.
 *    This is similar to net_client_request but the size of the reply
 *    data buffer is not known and must be determined from the first
 *    field in the reply argument buffer.
 */
int
net_client_request2 (int request, char *argbuf, int argsize, char *replybuf,
		     int replysize, char *databuf, int datasize,
		     char **replydata_ptr, int *replydatasize_ptr)
{
  unsigned int rc;
  int size;
  int reply_datasize, error;
  char *reply, *replydata;

  error = 0;
  *replydata_ptr = NULL;
  *replydatasize_ptr = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }
#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_add_entry (request, argsize + datasize);
    }
#endif /* HISTO */
  rc = css_send_req_to_server (net_Server_host,
			       request, argbuf, argsize,
			       databuf, datasize, replybuf, replysize);
  if (rc == 0)
    {
      error = css_Errno;
      return set_server_error (error);
    }

  error = css_receive_data_from_server (rc, &reply, &size);

  if (error != NO_ERROR)
    {
      return set_server_error (error);
    }
  else
    {
      error = COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
    }

  /* here we assume that the first integer in the reply is the length
     of the following data block */
  or_unpack_int (reply, &reply_datasize);

  if (reply_datasize)
    {
      if ((error == NO_ERROR)
	  && (replydata = (char *) malloc (reply_datasize)) != NULL)
	{
	  css_queue_receive_data_buffer (rc, replydata, reply_datasize);
	  error = css_receive_data_from_server (rc, &reply, &size);

	  if (error != NO_ERROR)
	    {
	      free_and_init (replydata);
	      return set_server_error (error);
	    }
	  else
	    {
	      error = COMPARE_SIZE_AND_BUFFER (&reply_datasize, size,
					       &replydata, reply);
	    }
	  *replydata_ptr = reply;
	  *replydatasize_ptr = size;
	}
      else
	{
	  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, 1);
	}
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_request_finished (request, replysize + *replydatasize_ptr);
    }
#endif /* HISTO */
  return (error);
}

/*
 * net_client_request2_no_malloc -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in):  byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf(in): data buffer to send (large)
 *   datasize(in): size of data buffer
 *   replydata(in): receive data buffer (large)
 *   replydatasize_ptr(in): size of expected reply data
 *
 * Note: This is one of two functions that is called to perform a server
 *    request.  All network interface routines will call either this
 *    functino or net_client_request.
 *    This is similar to net_client_request but the size of the reply
 *    data buffer is not known and must be determined from the first
 *    field in the reply argument buffer.
 */
int
net_client_request2_no_malloc (int request, char *argbuf, int argsize,
			       char *replybuf, int replysize,
			       char *databuf, int datasize,
			       char *replydata, int *replydatasize_ptr)
{
  unsigned int rc;
  int size;
  int reply_datasize, error;
  char *reply;

  error = 0;
  *replydatasize_ptr = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
    }
  else
    {
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_add_entry (request, argsize + datasize);
	}
#endif /* HISTO */
      rc = css_send_req_to_server (net_Server_host, request, argbuf,
				   argsize, databuf, datasize, replybuf,
				   replysize);
      if (rc == 0)
	{
	  return set_server_error (css_Errno);
	}

      error = css_receive_data_from_server (rc, &reply, &size);

      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
      else
	{
	  error = COMPARE_SIZE_AND_BUFFER (&replysize, size,
					   &replybuf, reply);
	}

      /* here we assume that the first integer in the reply is the length
         of the following data block */
      or_unpack_int (reply, &reply_datasize);

      if (reply_datasize)
	{
	  css_queue_receive_data_buffer (rc, replydata, reply_datasize);
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
	  else
	    {
	      error = COMPARE_SIZE_AND_BUFFER (&reply_datasize, size,
					       &replydata, reply);
	    }
	  *replydatasize_ptr = size;
	}
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_request_finished (request, replysize + *replydatasize_ptr);
	}
#endif /* HISTO */
    }
  return (error);
}

/*
 * net_client_request_3_data -
 *
 * return: error status (0 = success, non-zero = error)
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   databuf1(in): first data buffer to send
 *   datasize1(in): size of first data buffer
 *   databuf2(in): second data buffer to send
 *   datasize2(in): size of second data buffer
 *   reply0(in): first reply argument buffer (small)
 *   replysize0(in): size of first reply argument buffer
 *   reply1(in): second reply argument buffer
 *   replysize1(in): size of second reply argument buffer
 *   reply2(in): third reply argument buffer
 *   replysize2(in): size of third reply argument buffer
 *
 * Note: This is one of two functions that is called to perform a server
 *    request.  All network interface routines will call either this
 *    functino or net_client_request2.
 */
int
net_client_request_3_data (int request, char *argbuf, int argsize,
			   char *databuf1, int datasize1, char *databuf2,
			   int datasize2, char *reply0, int replysize0,
			   char *reply1, int replysize1, char *reply2,
			   int replysize2)
{
  unsigned int rid;
  int rc;
  int size;
  int p1_size, p2_size, error;
  char *ptr;

  error = rc = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      rc = ER_NET_SERVER_CRASHED;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, rc, 0);
    }
  else
    {
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_add_entry (request, argsize + datasize1 + datasize2);
	}
#endif /* HISTO */
      rid = css_send_req_to_server_2_data (net_Server_host,
					   request, argbuf, argsize,
					   databuf1, datasize1,
					   databuf2, datasize2, NULL, 0);
      if (rid == 0)
	{
	  return set_server_error (css_Errno);
	}

      css_queue_receive_data_buffer (rid, reply0, replysize0);
      error = css_receive_data_from_server (rid, &ptr, &size);
      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
      else
	{
	  /* Ignore this error status here, since the caller must check it */
	  ptr = or_unpack_int (reply0, &error);
	  ptr = or_unpack_int (ptr, &p1_size);
	  (void) or_unpack_int (ptr, &p2_size);

	  if (p1_size == 0)
	    {
	      return (rc);
	    }

	  css_queue_receive_data_buffer (rid, reply1, p1_size);
	  if (p2_size > 0)
	    {
	      css_queue_receive_data_buffer (rid, reply2, p2_size);
	    }
	  error = css_receive_data_from_server (rid, &ptr, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
	  else
	    {
	      error =
		COMPARE_SIZE_AND_BUFFER (&replysize1, size, &reply1, ptr);
	    }

	  if (p2_size > 0)
	    {
	      error = css_receive_data_from_server (rid, &ptr, &size);
	      if (error != NO_ERROR)
		{
		  return set_server_error (error);
		}
	      else
		{
		  error =
		    COMPARE_SIZE_AND_BUFFER (&replysize2, size, &reply2, ptr);
		}
	    }
	}
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_request_finished (request, replysize1 + replysize2);
	}
#endif /* HISTO */
    }
  return (rc);
}

/*
 * net_client_request_with_callback -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *   databuf1(in): first data buffer to send (large)
 *   datasize1(in): size of first data buffer
 *   databuf2(in): second data buffer to send (large)
 *   datasize2(in): size of second data buffer
 *   replydata_ptr1(in): first receive data buffer (large)
 *   replydatasize_ptr1(in): size of first expected reply data
 *   replydata_ptr2(in): second receive data buffer (large)
 *   replydatasize_ptr2(in): size of second expected reply data
 *
 * Note: This is one of the functions that is called to perform a server
 *    request.
 *    This is similar to net_client_request2, but the first
 *    field in the reply argument buffer is a request code which can
 *    cause the client to perform actions such as call methods.  When
 *    the actions are completed, a reply is sent to the server.  Eventually
 *    the server responds to the original request with a request code
 *    that indicates that the request is complete and this routine
 *    returns.
 */
int
net_client_request_with_callback (int request, char *argbuf, int argsize,
				  char *replybuf, int replysize,
				  char *databuf1, int datasize1,
				  char *databuf2, int datasize2,
				  char **replydata_ptr1,
				  int *replydatasize_ptr1,
				  char **replydata_ptr2,
				  int *replydatasize_ptr2)
{
  unsigned int rc;
  int size;
  int reply_datasize1, reply_datasize2, error;
  char *reply, *replydata, *ptr;
  QUERY_SERVER_REQUEST server_request;
  int server_request_num;

  error = 0;
  *replydata_ptr1 = NULL;
  *replydata_ptr2 = NULL;
  *replydatasize_ptr1 = 0;
  *replydatasize_ptr2 = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
    }
  else
    {
#ifdef HISTO
      if (net_Histo_setup)
	{
	  histo_add_entry (request, argsize + datasize1 + datasize2);
	}
#endif
      rc = css_send_req_to_server_2_data (net_Server_host, request, argbuf,
					  argsize, databuf1, datasize1,
					  databuf2, datasize2, replybuf,
					  replysize);
      if (rc == 0)
	{
	  return set_server_error (css_Errno);
	}

      do
	{
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
#if 0
	  else
	    {
	      error =
		COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
	    }
#endif

	  ptr = or_unpack_int (reply, &server_request_num);
	  server_request = (QUERY_SERVER_REQUEST) server_request_num;

	  switch (server_request)
	    {
	    case QUERY_END:
	      /* here we assume that the first integer in the reply is the length
	         of the following data block */
	      ptr = or_unpack_int (ptr, &reply_datasize1);
	      ptr = or_unpack_int (ptr, &reply_datasize2);

	      if (reply_datasize1)
		{
		  if ((error == NO_ERROR)
		      && (replydata =
			  (char *) malloc (reply_datasize1)) != NULL)
		    {
		      css_queue_receive_data_buffer (rc, replydata,
						     reply_datasize1);
		      error =
			css_receive_data_from_server (rc, &reply, &size);
		      if (error != NO_ERROR)
			{
			  free_and_init (replydata);
			  return set_server_error (error);
			}
		      else
			{
			  error =
			    COMPARE_SIZE_AND_BUFFER (&reply_datasize1,
						     size, &replydata, reply);
			}
		      *replydata_ptr1 = reply;
		      *replydatasize_ptr1 = size;

		    }
		  else
		    {
		      SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, 1);
		    }
		}

	      if (reply_datasize2)
		{
		  if ((error == NO_ERROR)
		      && (replydata = (char *) malloc (DB_PAGESIZE)) != NULL)
		    {
		      css_queue_receive_data_buffer (rc, replydata,
						     reply_datasize2);
		      error =
			css_receive_data_from_server (rc, &reply, &size);
		      if (error != NO_ERROR)
			{
			  free_and_init (replydata);
			  return set_server_error (error);
			}
		      else
			{
			  error =
			    COMPARE_SIZE_AND_BUFFER (&reply_datasize2,
						     size, &replydata, reply);
			}
		      *replydata_ptr2 = reply;
		      *replydatasize_ptr2 = size;

		    }
		  else
		    {
		      SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, 1);
		    }
		}
	      break;

	    case METHOD_CALL:
	      {
		char *methoddata;
		int methoddata_size;
		QFILE_LIST_ID *method_call_list_id = (QFILE_LIST_ID *) 0;
		METHOD_SIG_LIST *method_call_sig_list = (METHOD_SIG_LIST *) 0;

		er_clear ();
		error = NO_ERROR;
		/* here we assume that the first integer in the reply is the length
		   of the following data block */
		or_unpack_int (ptr, &methoddata_size);
		methoddata = (char *) malloc (methoddata_size);
		if (methoddata != NULL)
		  {
		    css_queue_receive_data_buffer (rc, methoddata,
						   methoddata_size);
		    error = css_receive_data_from_server (rc, &reply, &size);
		    if (error != NO_ERROR)
		      {
			free_and_init (methoddata);
			return set_server_error (error);
		      }
		    else
		      {
#if defined(CS_MODE)
			bool need_to_reset = false;
			if (method_request_id == 0)
			  {
			    method_request_id = CSS_RID_FROM_EID (rc);
			    need_to_reset = true;
			  }
#endif /* CS_MODE */
			error = COMPARE_SIZE_AND_BUFFER (&methoddata_size,
							 size, &methoddata,
							 reply);
			ptr = or_unpack_unbound_listid (methoddata,
							(void **)
							&method_call_list_id);
			method_call_list_id->last_pgptr = NULL;
			ptr = or_unpack_method_sig_list (ptr,
							 (void **)
							 &method_call_sig_list);
			free_and_init (methoddata);
			error = method_invoke_for_server (rc,
							  net_Server_host,
							  net_Server_name,
							  method_call_list_id,
							  method_call_sig_list);
			regu_free_listid (method_call_list_id);
			regu_free_method_sig_list (method_call_sig_list);
			if (error != NO_ERROR)
			  {
			    error = er_errid ();
			    if (error == NO_ERROR)
			      {
				error = ER_NET_SERVER_DATA_RECEIVE;
				er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE,
					error, 0);
			      }
			  }
			else
			  {
			    error = NO_ERROR;
			  }
#if defined(CS_MODE)
			if (need_to_reset == true)
			  {
			    method_request_id = 0;
			    need_to_reset = false;
			  }
#endif /* CS_MODE */
		      }
		  }
		else
		  {
		    SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, 1);
		  }

		if (error != NO_ERROR)
		  {
		    return_error_to_server (net_Server_host, rc);
		    method_send_error_to_server (rc, net_Server_host,
						 net_Server_name);
		  }
		css_queue_receive_data_buffer (rc, replybuf, replysize);
	      }
	      break;

	      /*
	       * A code of END_CALLBACK is followed immediately by an
	       * integer returning status from the remote call.  The second
	       * integer represents the return value and must be returned
	       * to the calling function.
	       */
	    case END_CALLBACK:
	      /* The calling function will have to ignore this value in
	       * the reply buffer.
	       */
	      error = NO_ERROR;
	      break;

	    case ASYNC_OBTAIN_USER_INPUT:
	      {
		FILEIO_REMOTE_PROMPT_TYPE prompt_id;
		int length;
		char *promptdata = NULL;
		char user_response_buffer[FILEIO_MAX_USER_RESPONSE_SIZE + 1];
		char *user_response_ptr = user_response_buffer;
		int pr_status = ER_FAILED;
		int pr_len = 0;
		bool response_needed = false;
		bool retry_in = true;
		int x;
		/* The following variables are need to decode the data packet */
		char *display_string;
		char *prompt = NULL;
		char *failure_prompt = NULL;
		char *secondary_prompt = NULL;
		int range_lower, range_higher;
		int reprompt_value;
		int error2;
		char *a_ptr;

		ptr = or_unpack_int (ptr, (int *) &prompt_id);
		ptr = or_unpack_int (ptr, &length);
		promptdata = (char *) malloc (MAX (length,
						   FILEIO_MAX_USER_RESPONSE_SIZE
						   + OR_INT_SIZE));
		if (promptdata != NULL)
		  {
		    css_queue_receive_data_buffer (rc, promptdata, length);
		    error =
		      css_receive_data_from_server (rc, &reply, &length);
		    if (error != NO_ERROR)
		      {
			server_request = END_CALLBACK;
			free_and_init (promptdata);
			return set_server_error (error);
		      }
		    else
		      {
			ptr = or_unpack_string_nocopy (reply, &prompt);
			/*
			 * the following data are used depending on prompt type
			 * but will always be in the input stream
			 */
			ptr = or_unpack_string_nocopy (ptr, &failure_prompt);
			ptr = or_unpack_int (ptr, &range_lower);
			ptr = or_unpack_int (ptr, &range_higher);
			ptr =
			  or_unpack_string_nocopy (ptr, &secondary_prompt);
			ptr = or_unpack_int (ptr, &reprompt_value);
		      }

		    display_string = prompt;

		    memset (user_response_buffer, 0,
			    sizeof (user_response_buffer));

		    while (error == NO_ERROR && retry_in)
		      {
			/* Display prompt, then get user's input. */
			fprintf (stdout, display_string);
			pr_status = ER_FAILED;
			pr_len = 0;
			retry_in = false;

			if (prompt_id != FILEIO_PROMPT_DISPLAY_ONLY)
			  {
			    error2 = scanf ("%s", user_response_ptr);
			    if (error2 > 0)
			      {
				/* basic input int validation before we send it back */
				switch (prompt_id)
				  {
				  case FILEIO_PROMPT_RANGE_TYPE:
				    /* Numeric range checking */
				    x = strtol (user_response_ptr, &a_ptr,
						10);
				    if (a_ptr == user_response_ptr
					|| x < range_lower
					|| x > range_higher)
				      {
					fprintf (stdout, failure_prompt);
					retry_in = true;
				      }
				    else
				      {
					response_needed = true;
					pr_status = NO_ERROR;
				      }
				    break;

				    /*
				     * simply boolean (y, yes, 1, n, no, 0)
				     * validation
				     */
				  case FILEIO_PROMPT_BOOLEAN_TYPE:
				    if ((char_tolower (*user_response_ptr) ==
					 'y')
					|| (*user_response_ptr == '1')
					||
					(intl_mbs_casecmp
					 (user_response_ptr, "yes") == 0))
				      {
					response_needed = true;
					pr_status = NO_ERROR;
					/* convert all affirmate answers into '1' */
					strcpy (user_response_ptr, "1");
				      }
				    else
				      {
					/* assume negative */
					response_needed = true;
					pr_status = NO_ERROR;
					/* convert all negative answers into '0' */
					strcpy (user_response_ptr, "0");
				      }
				    break;

				    /* no validation to do */
				  case FILEIO_PROMPT_STRING_TYPE:
				    response_needed = true;
				    pr_status = NO_ERROR;
				    break;

				    /* Validate initial prompt, then post secondary
				     * prompt
				     */
				  case FILEIO_PROMPT_RANGE_WITH_SECONDARY_STRING_TYPE:
				    /* Numeric range checking on the first promp,
				     * but user's answer we really want is the second
				     * prompt
				     */
				    x = strtol (user_response_ptr, &a_ptr,
						10);
				    if (a_ptr == user_response_ptr
					|| x < range_lower
					|| x > range_higher)
				      {
					fprintf (stdout, failure_prompt);
					retry_in = true;
				      }
				    else if (x == reprompt_value)
				      {
					/* The first answer requires another prompt */
					display_string = secondary_prompt;
					retry_in = true;
					prompt_id = FILEIO_PROMPT_STRING_TYPE;
					/* moving the response buffer ptr forward insures
					 * that both the first response and the second
					 * are included in the buffer. (no delimiter or null
					 * bytes allowed)
					 */
					user_response_ptr +=
					  strlen (user_response_ptr);
				      }
				    else
				      {
					/* This answer was sufficient */
					response_needed = true;
					pr_status = NO_ERROR;
				      }
				    break;

				  default:
				    /* should we treat this as an error? */
				    response_needed = true;
				    pr_status = NO_ERROR;
				  }
			      }
			    else if (error2 == 0)
			      {
				retry_in = true;
			      }
			    else
			      {
				pr_status = ER_FAILED;
			      }
			  }
			else
			  {
			    response_needed = true;
			    pr_status = NO_ERROR;
			  }
		      }		/* while */

		    /* Return the user's answer to the server.
		     * All of the cases above should get to here after looping
		     * or whatever is necessary and provide
		     * indication of local errors (pr_status), as well as provide
		     * a string in user_response.  We send back to the
		     * server an int (status) followed by a string.
		     */
		    /* check for overflow, could be dangerous */
		    pr_len = strlen (user_response_buffer);
		    if (pr_len > FILEIO_MAX_USER_RESPONSE_SIZE)
		      {
			error = ER_NET_DATA_TRUNCATED;
			er_set (ER_FATAL_ERROR_SEVERITY, ARG_FILE_LINE, error,
				0);
			pr_status = ER_FAILED;
		      }

		    if (error)
		      {
			pr_status = ER_FAILED;
		      }

		    /* we already malloced large enough buffer, reuse promptdata */
		    ptr = or_pack_int (promptdata, pr_status);
		    if (response_needed)
		      {
			ptr = or_pack_string_with_length (ptr,
							  user_response_buffer,
							  pr_len);
		      }
		    error2 = net_client_send_data (net_Server_host, rc,
						   promptdata,
						   CAST_STRLEN (ptr -
								promptdata));
		    if (error2 != NO_ERROR)
		      {
			/* the error should have already been generated */
			server_request = END_CALLBACK;
		      }
		    if (error == NO_ERROR && error2 != NO_ERROR)
		      {
			error = error2;
		      }

		    if (error != NO_ERROR)
		      {
			server_request = END_CALLBACK;
			/* Do we need to tell the server about it? */
			return_error_to_server (net_Server_host, rc);
		      }
		  }
		else
		  {
		    /* send back some kind of error to server */
		    SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, 1);

		    /* Do we need to tell the server? */
		    server_request = END_CALLBACK;	/* force a stop */
		    return_error_to_server (net_Server_host, rc);
		  }

		/* Clean up and avoid leaks */
		if (promptdata)
		  {
		    free_and_init (promptdata);
		  }
	      }
	      /* expecting another reply */
	      css_queue_receive_data_buffer (rc, replybuf, replysize);

	      break;

	    default:
	      error = ER_NET_SERVER_DATA_RECEIVE;
	      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
	      server_request = QUERY_END;
	      break;
	    }
	}
      while (server_request != END_CALLBACK && server_request != QUERY_END);

#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_request_finished (request, replysize + *replydatasize_ptr1 +
				  *replydatasize_ptr2);
	}
#endif /* HISTO */
    }
  return (error);
}

/*
 * net_client_request_with_context -
 *
 * return:
 * Note:
 */
int
net_client_request_with_context (LOGWR_CONTEXT * ctx_ptr,
				 int request, char *argbuf, int argsize,
				 char *replybuf, int replysize,
				 char *databuf1, int datasize1,
				 char *databuf2, int datasize2,
				 char **replydata_ptr1,
				 int *replydatasize_ptr1,
				 char **replydata_ptr2,
				 int *replydatasize_ptr2)
{
  unsigned int rc;
  int size;
  int error;
  char *reply, *ptr;
  QUERY_SERVER_REQUEST server_request;
  int server_request_num;

  error = 0;
  *replydata_ptr1 = NULL;
  *replydata_ptr2 = NULL;
  *replydatasize_ptr1 = 0;
  *replydatasize_ptr2 = 0;

  if (net_Server_name[0] == '\0')
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = ER_NET_SERVER_CRASHED;
    }
  else
    {
#ifdef HISTO
      if (net_Histo_setup)
	{
	  histo_add_entry (request, argsize + datasize1 + datasize2);
	}
#endif
      if (ctx_ptr->rc == -1)
	{
	  /* It sends a new request */
	  rc = css_send_req_to_server_2_data (net_Server_host, request,
					      argbuf, argsize, databuf1,
					      datasize1, databuf2, datasize2,
					      replybuf, replysize);
	  if (rc == 0)
	    {
	      return set_server_error (css_Errno);
	    }
	  ctx_ptr->rc = rc;
	}
      else
	{
	  /* It sends the same request with new arguments */
	  rc = ctx_ptr->rc;
	  error = net_client_send_data (net_Server_host, rc, argbuf, argsize);
	  if (error != NO_ERROR)
	    {
	      return error;
	    }
	  (void) css_queue_receive_data_buffer (rc, replybuf, replysize);
	}

      do
	{
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
	  else
	    {
	      error =
		COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
	      if (error != NO_ERROR)
		{
		  return error;
		}
	    }
	  ptr = or_unpack_int (reply, &server_request_num);
	  server_request = (QUERY_SERVER_REQUEST) server_request_num;

	  switch (server_request)
	    {
	    case GET_NEXT_LOG_PAGES:
	      {
		int length;
		ptr = or_unpack_int (ptr, (int *) (&length));
		error = net_client_get_next_pages (rc, replybuf, replysize, 
						   length);
	      }
	      break;
	    case END_CALLBACK:
	      ptr = or_unpack_int (ptr, &error);
	      if (error != ctx_ptr->last_error)
		{
		  /* By server error or shutdown */
		  error = ER_NET_SERVER_CRASHED;
		  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
		}
	      ctx_ptr->shutdown = true;
	      break;
	    default:
	      /* TODO: handle the unknown request as an error */
	      error = ER_NET_SERVER_DATA_RECEIVE;
	      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
	      ctx_ptr->shutdown = true;
	      break;
	    }
	}
      while (false /*server_request != END_CALLBACK */ );
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_request_finished (request, replysize + *replydatasize_ptr1 +
				  *replydatasize_ptr2);
	}
#endif /* HISTO */
    }
  return (error);
}

/*
 * net_client_get_next_pages -
 *
 * return:
 *
 *   rc(in): pre-allocated data buffer
 *   replybuf(in): reply argument buffer
 *   replysize(in): reply argument buffer size
 *   ptr(in): pre-allocated data buffer
 *
 * Note:
 */
int
net_client_get_next_pages (int rc, char *replybuf, int replysize, int length)
{
  char *reply;
  int error;

  assert (logwr_Gl.logpg_area_size >= length);

  (void) css_queue_receive_data_buffer (rc, logwr_Gl.logpg_area,
					logwr_Gl.logpg_area_size);
  error =
    css_receive_data_from_server (rc, &reply, &logwr_Gl.logpg_fill_size);
  if (error != NO_ERROR)
    {
      return set_server_error (error);
    }
  else
    {
      if ((error = logwr_set_hdr_and_flush_info ()) != NO_ERROR)
	return error;

      switch (logwr_Gl.mode)
	{
	case LOGWR_MODE_SYNC:
	case LOGWR_MODE_SEMISYNC:
	  error = logwr_write_log_pages ();
	  break;
	case LOGWR_MODE_ASYNC:
	  logwr_Gl.action |= LOGWR_ACTION_ASYNC_WRITE;
	  break;
	default:
	  break;
	}
    }
  return error;
}

/*
 * net_client_request_buffer -
 *
 * return: error status
 *
 *   rc(in): pre-allocated data buffer
 *   buf_ptr(in): pre-allocated data buffer
 *   expected_size(in): size of data buffer
 *
 * Note: This is used to read an expected network buffer.
 *    Returns non-zero if an error condition was detected.
 *
 *    the other two client request functions should use this, re-write after
 *    1.1 release
 */
static int
net_client_request_buffer (unsigned int rc, char **buf_ptr, int expected_size)
{
  int error;
  int reply_size;
  char *buffer, *reply;

  error = 0;
  *buf_ptr = NULL;

  buffer = (char *) malloc (expected_size);
  if (buffer != NULL)
    {
      css_queue_receive_data_buffer (rc, buffer, expected_size);
      error = css_receive_data_from_server (rc, &reply, &reply_size);
      if (error != NO_ERROR)
	{
	  free_and_init (buffer);
	  return set_server_error (error);
	}
      else
	{
	  error = COMPARE_SIZE_AND_BUFFER (&expected_size, reply_size,
					   &buffer, reply);
	}

      if (error)
	{
	  free_and_init (buffer);
	}
      else
	{
	  *buf_ptr = buffer;
	}
    }
  else
    {
      SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, 1);
    }

  return (error);
}

/*
 * net_client_request3 -
 *
 * return: error status
 *
 *   request(in): request id
 *   argbuf(in): request argument buffer
 *   argsize(in): request argument buffer size
 *   replybuf(in): reply argument buffer
 *   replysize(in): reply argument buffer size
 *   databuf(in): send data buffer
 *   datasize(in): send data buffer size
 *   replydata_ptr(in): returned data buffer pointer
 *   replydatasize_ptr(in): returned data buffer size
 *   replydata_ptr2(in): second reply data buffer pointer
 *   replydatasize_ptr2(in): second reply buffer size
 *
 * Note: Like net_client_request2 but expectes two reply data buffers.
 *    Need to generalize this.
 */
int
net_client_request3 (int request, char *argbuf, int argsize,
		     char *replybuf, int replysize, char *databuf,
		     int datasize, char **replydata_ptr,
		     int *replydatasize_ptr, char **replydata_ptr2,
		     int *replydatasize_ptr2)
{
  unsigned int rc;
  int size;
  int reply_datasize, reply_datasize2, error;
  char *reply, *replydata, *replydata2;
  char *ptr;

  error = 0;
  *replydata_ptr = NULL;
  *replydata_ptr2 = NULL;
  *replydatasize_ptr = 0;
  *replydatasize_ptr2 = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
    }
  else
    {
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_add_entry (request, argsize + datasize);
	}
#endif /* HISTO */
      rc =
	css_send_req_to_server (net_Server_host, request, argbuf, argsize,
				databuf, datasize, replybuf, replysize);
      if (rc == 0)
	{
	  return set_server_error (css_Errno);
	}

      error = css_receive_data_from_server (rc, &reply, &size);
      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
      else
	{
	  error =
	    COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
	}

      /* here we assume that the first two integers in the reply are the
         lengths of the following data blocks */
      ptr = or_unpack_int (reply, &reply_datasize);
      (void) or_unpack_int (ptr, &reply_datasize2);

      replydata = NULL;
      replydata2 = NULL;

      if (reply_datasize)
	{
	  error = net_client_request_buffer (rc, &replydata, reply_datasize);
	}

      if ((error == NO_ERROR) && reply_datasize2)
	{
	  error =
	    net_client_request_buffer (rc, &replydata2, reply_datasize2);
	}

      if (error)
	{
	  if (replydata != NULL)
	    {
	      free_and_init (replydata);
	      replydata = NULL;
	    }
	  if (replydata2)
	    {
	      free_and_init (replydata2);
	      replydata2 = NULL;
	    }
	}

      *replydata_ptr = replydata;
      *replydatasize_ptr = reply_datasize;
      *replydata_ptr2 = replydata2;
      *replydatasize_ptr2 = reply_datasize2;
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_request_finished (request, replysize + *replydatasize_ptr +
				  *replydatasize_ptr2);
	}
#endif /* HISTO */
    }
  return (error);
}

/*
 * net_client_request_recv_copyarea -
 *
 * return:
 *
 *   request(in):
 *   argbuf(in):
 *   argsize(in):
 *   replybuf(in):
 *   replysize(in):
 *   reply_copy_area(in):
 *
 * Note:
 */
int
net_client_request_recv_copyarea (int request,
				  char *argbuf, int argsize,
				  char *replybuf,
				  int replysize,
				  LC_COPYAREA ** reply_copy_area)
{
  unsigned int rc;
  int size;
  int error;
  char *reply;
  int content_size;
  char *content_ptr;
  int num_objs;
  char *packed_desc;
  int packed_desc_size;

  error = 0;
  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
    }
  else
    {
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_add_entry (request, argsize);
	}
#endif /* HISTO */

      rc =
	css_send_req_to_server (net_Server_host, request, argbuf, argsize,
				NULL, 0, replybuf, replysize);
      if (rc == 0)
	{
	  return set_server_error (css_Errno);
	}

      /*
       * Receive replybuf
       */

      error = css_receive_data_from_server (rc, &reply, &size);
      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
      else
	{
	  error =
	    COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
	}

      /*
       * Receive copyarea
       * Here assume that the next two integers in the reply are the lengths of
       * the copy descriptor and content descriptor
       */

      reply = or_unpack_int (reply, &num_objs);
      reply = or_unpack_int (reply, &packed_desc_size);
      reply = or_unpack_int (reply, &content_size);

      if (packed_desc_size != 0 || content_size != 0)
	{
	  if (error == NO_ERROR)
	    {
	      *reply_copy_area = locator_recv_allocate_copyarea (num_objs,
								 &packed_desc,
								 packed_desc_size,
								 &content_ptr,
								 content_size);
	      if (*reply_copy_area != NULL)
		{
		  if (packed_desc_size > 0)
		    {
		      css_queue_receive_data_buffer (rc, packed_desc,
						     packed_desc_size);
		      error = css_receive_data_from_server (rc, &packed_desc,
							    &size);
		      if (error != NO_ERROR)
			{
			  free_and_init (packed_desc);
			  return set_server_error (error);
			}
		      else
			{
			  locator_unpack_copy_area_descriptor (num_objs,
							       *reply_copy_area,
							       packed_desc);
			  free_and_init (packed_desc);
			}
		    }

		  if (content_size > 0)
		    {
		      error = css_queue_receive_data_buffer (rc, content_ptr,
							     content_size);
		      if (error != NO_ERROR)
			{
			  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc,
								   1);
			}
		      else
			{
			  error =
			    css_receive_data_from_server (rc, &content_ptr,
							  &size);
			}
		      if (error != NO_ERROR)
			{
			  return set_server_error (error);
			}
		    }

		}
	      else
		{
		  int num_packets = 0;

		  if (packed_desc_size > 0)
		    {
		      num_packets++;
		    }
		  if (content_size > 0)
		    {
		      num_packets++;
		    }
		  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc,
							   num_packets);
		}
	    }
	  else
	    {
	      int num_packets = 0;

	      if (packed_desc_size > 0)
		{
		  num_packets++;
		}
	      if (content_size > 0)
		{
		  num_packets++;
		}
	      SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc,
						       num_packets);

	    }
	}
#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_request_finished (request, replysize + content_size +
				  packed_desc_size);
	}
#endif /* HISTO */
    }
  return (error);
}

/*
 * net_client_request_recv_logarea -
 *
 * return:
 *
 *   request(in):
 *   argbuf(in):
 *   argsize(in):
 *   replybuf(in):
 *   replysize(in):
 *   reply_log_area(in):
 *
 * Note:
 */
int
net_client_request_recv_logarea (int request, char *argbuf,
				 int argsize, char *replybuf,
				 int replysize, LOG_COPY ** reply_log_area)
{
  unsigned int rc;
  int size;
  int error;
  char *reply;
  int content_size;
  char *content_ptr;
  int num_records;
  char *packed_desc;
  int packed_desc_size;

  error = 0;
  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_add_entry (request, argsize);
    }
#endif /* HISTO */

  rc =
    css_send_req_to_server (net_Server_host, request, argbuf, argsize,
			    NULL, 0, replybuf, replysize);
  if (rc == 0)
    {
      return set_server_error (css_Errno);
    }

  /*
   * Receive replybuf
   */
  error = css_receive_data_from_server (rc, &reply, &size);
  if (error != NO_ERROR)
    {
      return set_server_error (error);
    }
  else
    {
      error = COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
    }

  /*
   * Receive logarea
   * Here assume that the next two integers in the reply are the lengths of
   * the copy descriptor and content descriptor
   */

  reply = or_unpack_int (reply, &num_records);
  reply = or_unpack_int (reply, &packed_desc_size);
  reply = or_unpack_int (reply, &content_size);

  /* allocate the logarea */
  *reply_log_area = NULL;
  if (packed_desc_size != 0 || content_size != 0)
    {
      if (error == NO_ERROR)
	{
	  *reply_log_area = log_copy_area_malloc_recv (num_records,
						       &packed_desc,
						       packed_desc_size,
						       &content_ptr,
						       content_size);
	  if (*reply_log_area != NULL)
	    {
	      if (packed_desc_size > 0)
		{
		  css_queue_receive_data_buffer (rc, packed_desc,
						 packed_desc_size);
		  error = css_receive_data_from_server (rc, &packed_desc,
							&size);
		  if (error != NO_ERROR)
		    {
		      free_and_init (packed_desc);
		      return set_server_error (error);
		    }
		  log_unpack_descriptors (num_records, *reply_log_area,
					  packed_desc);
		  free_and_init (packed_desc);
		}

	      if (content_size > 0)
		{
		  css_queue_receive_data_buffer (rc, content_ptr,
						 content_size);
		  error = css_receive_data_from_server (rc, &content_ptr,
							&size);
		  if (error != NO_ERROR)
		    {
		      return set_server_error (error);
		    }
		}
	    }
	  else
	    {
	      int num_packets = 0;

	      if (packed_desc_size > 0)
		{
		  num_packets++;
		}
	      if (content_size > 0)
		{
		  num_packets++;
		}
	      SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc,
						       num_packets);
	    }
	}
      else
	{
	  int num_packets = 0;

	  if (packed_desc_size > 0)
	    {
	      num_packets++;
	    }
	  if (content_size > 0)
	    {
	      num_packets++;
	    }
	  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, num_packets);

	}
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_request_finished (request, replysize + content_size +
			      packed_desc_size);
    }
#endif /* HISTO */

  return (error);
}

/*
 * net_client_request_2recv_copyarea -
 *
 * return:
 *
 *   request(in):
 *   argbuf(in):
 *   argsize(in):
 *   replybuf(in):
 *   replysize(in):
 *   databuf(in):
 *   datasize(in):
 *   recvbuffer(in):
 *   recvbuffer_size(in):
 *   reply_copy_area(in):
 *   eid(in):
 *
 * Note:
 */
int
net_client_request_2recv_copyarea (int request, char *argbuf, int argsize,
				   char *replybuf, int replysize,
				   char *databuf, int datasize,
				   char *recvbuffer, int recvbuffer_size,
				   LC_COPYAREA ** reply_copy_area, int *eid)
{
  unsigned int rc;
  int size;
  int p_size, error;
  char *reply;
  int content_size;
  char *content_ptr;
  int num_objs;
  char *packed_desc;
  int packed_desc_size;

  error = 0;
  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }
#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_add_entry (request, argsize + datasize);
    }
#endif /* HISTO */

  rc =
    css_send_req_to_server (net_Server_host, request, argbuf, argsize,
			    databuf, datasize, replybuf, replysize);
  if (rc == 0)
    {
      return set_server_error (css_Errno);
    }

  *eid = rc;

  /*
   * Receive replybuf
   */

  error = css_receive_data_from_server (rc, &reply, &size);
  if (error != NO_ERROR)
    {
      return set_server_error (error);
    }
  else
    {
      error = COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
    }

  /*
   * Receive recvbuffer
   * Here we assume that the first integer in the reply is the length
   * of the following data block
   */

  replybuf = or_unpack_int (replybuf, &p_size);

  if (recvbuffer_size < p_size)
    {
      /* too big for what we allocated */
      error = set_server_error (CANT_ALLOC_BUFFER);
    }

  if (p_size > 0)
    {
      if (error)
	{
	  /* maintain error status.  If we continued without checking
	   * this, error could become NO_ERROR and caller would never
	   * know.
	   */
	  css_receive_data_from_server (rc, &reply, &size);
	}
      else
	{
	  css_queue_receive_data_buffer (rc, recvbuffer, p_size);
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
	  else
	    {
	      /* we expect that the sizes won't match, but we must be
	       * sure that the we can accomodate the data in our buffer.
	       * So, don't use COMPARE_SIZE_AND_BUFFER() here.
	       */
	      if (recvbuffer_size < size)
		{
		  error = ER_NET_DATASIZE_MISMATCH;
		  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2,
			  recvbuffer_size, size);
		}
	      else
		{
		  recvbuffer_size = size;
		}

	      if (reply != recvbuffer)
		{
		  error = ER_NET_UNUSED_BUFFER;
		  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
		}
	    }
	}
    }

  /*
   * Receive copyarea
   * Here assume that the next two integers in the reply are the lengths of
   * the copy descriptor and content descriptor
   */

  replybuf = or_unpack_int (replybuf, &num_objs);
  replybuf = or_unpack_int (replybuf, &packed_desc_size);
  replybuf = or_unpack_int (replybuf, &content_size);

  /* allocate the copyarea */
  *reply_copy_area = NULL;
  if (packed_desc_size != 0 || content_size != 0)
    {
      if (error == NO_ERROR)
	{
	  *reply_copy_area = locator_recv_allocate_copyarea (num_objs,
							     &packed_desc,
							     packed_desc_size,
							     &content_ptr,
							     content_size);
	  if (*reply_copy_area != NULL)
	    {
	      if (packed_desc_size > 0)
		{
		  css_queue_receive_data_buffer (rc, packed_desc,
						 packed_desc_size);
		  error = css_receive_data_from_server (rc, &packed_desc,
							&size);
		  if (error != NO_ERROR)
		    {
		      free_and_init (packed_desc);
		      return set_server_error (error);
		    }
		  else
		    {
		      locator_unpack_copy_area_descriptor (num_objs,
							   *reply_copy_area,
							   packed_desc);
		      free_and_init (packed_desc);
		    }
		}

	      if (content_size > 0)
		{
		  css_queue_receive_data_buffer (rc, content_ptr,
						 content_size);
		  error = css_receive_data_from_server (rc, &content_ptr,
							&size);
		  if (error != NO_ERROR)
		    {
		      return set_server_error (error);
		    }
		}
	    }
	  else
	    {
	      int num_packets = 0;

	      if (packed_desc_size > 0)
		{
		  num_packets++;
		}
	      if (content_size > 0)
		{
		  num_packets++;
		}
	      SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc,
						       num_packets);
	    }
	}
      else
	{
	  int num_packets = 0;

	  if (packed_desc_size > 0)
	    {
	      num_packets++;
	    }
	  if (content_size > 0)
	    {
	      num_packets++;
	    }
	  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, num_packets);

	}
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_request_finished (request, replysize + recvbuffer_size +
			      content_size + packed_desc_size);
    }
#endif /* HISTO */
  return (error);
}

/*
 * net_client_recv_copyarea -
 *
 * return:
 *
 *   request(in):
 *   replybuf(in):
 *   replysize(in):
 *   recvbuffer(in):
 *   recvbuffer_size(in):
 *   reply_copy_area(in):
 *   rc(in):
 *
 * Note:
 */
int
net_client_recv_copyarea (int request, char *replybuf, int replysize,
			  char *recvbuffer, int recvbuffer_size,
			  LC_COPYAREA ** reply_copy_area, int rc)
{
  int size;
  int error, p_size;
  char *reply;
  int content_size;
  char *content_ptr;
  int num_objs;
  char *packed_desc;
  int packed_desc_size;

  error = 0;
  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }
#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_add_entry (request, 0);
    }
#endif /* HISTO */

  /*
   * Receive replybuf
   */

  css_queue_receive_data_buffer (rc, replybuf, replysize);
  error = css_receive_data_from_server (rc, &reply, &size);
  if (error != NO_ERROR)
    {
      return set_server_error (error);
    }
  else
    {
      error = COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
    }

  /*
   * Receive recvbuffer
   * Here we assume that the first integer in the reply is the length
   * of the following data block
   */

  replybuf = or_unpack_int (replybuf, &p_size);

  if (recvbuffer_size < p_size)
    {
      error = set_server_error (CANT_ALLOC_BUFFER);
    }

  if (p_size > 0)
    {
      if (error)
	{
	  /* maintain error status.  If we continued without checking
	   * this, error could become NO_ERROR and caller would never
	   * know.
	   */
	  css_receive_data_from_server (rc, &reply, &size);
	}
      else
	{
	  css_queue_receive_data_buffer (rc, recvbuffer, p_size);
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      return set_server_error (error);
	    }
	  else
	    {
	      if (recvbuffer_size < size)
		{
		  /* we expect that the sizes won't match, but we must be
		   * sure that the we can accomodate the data in our buffer.
		   * So, don't use COMPARE_SIZE_AND_BUFFER() here.
		   */
		  error = ER_NET_DATASIZE_MISMATCH;
		  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2,
			  recvbuffer_size, size);
		}
	      else
		{
		  recvbuffer_size = size;
		}

	      if (reply != recvbuffer)
		{
		  error = ER_NET_UNUSED_BUFFER;
		  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
		}
	    }
	}
    }

  /*
   * Receive copyarea
   * Here assume that the next two integers in the reply are the lengths of
   * the copy descriptor and content descriptor
   */

  replybuf = or_unpack_int (replybuf, &num_objs);
  replybuf = or_unpack_int (replybuf, &packed_desc_size);
  replybuf = or_unpack_int (replybuf, &content_size);

  /* allocate the copyarea */
  *reply_copy_area = NULL;
  if (packed_desc_size != 0 || content_size != 0)
    {
      if (error == NO_ERROR)
	{
	  *reply_copy_area = locator_recv_allocate_copyarea (num_objs,
							     &packed_desc,
							     packed_desc_size,
							     &content_ptr,
							     content_size);
	  if (*reply_copy_area != NULL)
	    {
	      if (packed_desc_size > 0)
		{
		  css_queue_receive_data_buffer (rc, packed_desc,
						 packed_desc_size);
		  error = css_receive_data_from_server (rc, &packed_desc,
							&size);
		  if (error != NO_ERROR)
		    {
		      free_and_init (packed_desc);
		      return set_server_error (error);
		    }
		  else
		    {
		      locator_unpack_copy_area_descriptor (num_objs,
							   *reply_copy_area,
							   packed_desc);
		      free_and_init (packed_desc);
		    }
		}

	      if (content_size > 0)
		{
		  css_queue_receive_data_buffer (rc, content_ptr,
						 content_size);
		  error = css_receive_data_from_server (rc, &content_ptr,
							&size);
		  if (error != NO_ERROR)
		    {
		      return set_server_error (error);
		    }
		}

	    }
	  else
	    {
	      int num_packets = 0;

	      if (packed_desc_size > 0)
		{
		  num_packets++;
		}
	      if (content_size > 0)
		{
		  num_packets++;
		}
	      SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc,
						       num_packets);
	    }
	}
      else
	{
	  int num_packets = 0;

	  if (packed_desc_size > 0)
	    {
	      num_packets++;
	    }
	  if (content_size > 0)
	    {
	      num_packets++;
	    }
	  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, num_packets);
	}
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_request_finished (request, replysize + recvbuffer_size +
			      content_size + packed_desc_size);
    }
#endif /* HISTO */

  return (error);
}

/*
 * net_client_request_3recv_copyarea -
 *
 * return:
 *
 *   request(in):
 *   argbuf(in):
 *   argsize(in):
 *   replybuf(in):
 *   replysize(in):
 *   databuf(in):
 *   datasize(in):
 *   recvbuffer(in):
 *   recvbuffer_size(in):
 *   reply_copy_area(in):
 *
 * Note:
 */
int
net_client_request_3recv_copyarea (int request, char *argbuf, int argsize,
				   char *replybuf, int replysize,
				   char *databuf, int datasize,
				   char **recvbuffer, int *recvbuffer_size,
				   LC_COPYAREA ** reply_copy_area)
{
  unsigned int rc;
  int size;
  int p_size, error;
  char *reply;
  int content_size;
  char *content_ptr;
  int num_objs;
  char *packed_desc;
  int packed_desc_size;

  error = 0;
  *recvbuffer = NULL;
  *recvbuffer_size = 0;

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = -1;
      return error;
    }
#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_add_entry (request, argsize + datasize);
    }
#endif /* HISTO */

  rc = css_send_req_to_server (net_Server_host, request, argbuf, argsize,
			       databuf, datasize, replybuf, replysize);
  if (rc == 0)
    {
      return set_server_error (css_Errno);
    }

  /*
   * Receive replybuf
   */
  error = css_receive_data_from_server (rc, &reply, &size);
  if (error != NO_ERROR)
    {
      return set_server_error (error);
    }
  else
    {
      error = COMPARE_SIZE_AND_BUFFER (&replysize, size, &replybuf, reply);
    }

  /*
   * Receive recvbuffer
   * Here we assume that the first integer in the reply is the length
   * of the following data block
   */

  replybuf = or_unpack_int (replybuf, &p_size);

  if (p_size > 0)
    {
      *recvbuffer_size = p_size;

      if ((error == NO_ERROR)
	  && (*recvbuffer = (char *) malloc (p_size)) != NULL)
	{
	  css_queue_receive_data_buffer (rc, *recvbuffer, p_size);
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      free_and_init (*recvbuffer);
	      return set_server_error (error);
	    }
	  else
	    {
	      error = COMPARE_SIZE_AND_BUFFER (recvbuffer_size, size,
					       recvbuffer, reply);
	    }
	}
      else
	{
	  *recvbuffer_size = 0;
	  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, 1);
	}
    }

  /*
   * Receive copyarea
   * Here assume that the next two integers in the reply are the lengths of
   * the copy descriptor and content descriptor
   */

  replybuf = or_unpack_int (replybuf, &num_objs);
  replybuf = or_unpack_int (replybuf, &packed_desc_size);
  replybuf = or_unpack_int (replybuf, &content_size);

  /* allocate the copyarea */
  *reply_copy_area = NULL;
  if (packed_desc_size != 0 || content_size != 0)
    {
      if ((error == NO_ERROR)
	  && ((*reply_copy_area = locator_recv_allocate_copyarea (num_objs,
								  &packed_desc,
								  packed_desc_size,
								  &content_ptr,
								  content_size))
	      != NULL))
	{
	  if (packed_desc_size > 0)
	    {
	      css_queue_receive_data_buffer (rc, packed_desc,
					     packed_desc_size);
	      error = css_receive_data_from_server (rc, &packed_desc, &size);
	      if (error != NO_ERROR)
		{
		  free_and_init (packed_desc);
		  return set_server_error (error);
		}
	      else
		{
		  locator_unpack_copy_area_descriptor (num_objs,
						       *reply_copy_area,
						       packed_desc);
		  free_and_init (packed_desc);
		}
	    }

	  if (content_size > 0)
	    {
	      css_queue_receive_data_buffer (rc, content_ptr, content_size);
	      error = css_receive_data_from_server (rc, &content_ptr, &size);
	      if (error != NO_ERROR)
		{
		  return set_server_error (error);
		}
	    }
	}
      else
	{
	  int num_packets = 0;

	  if (packed_desc_size > 0)
	    {
	      num_packets++;
	    }
	  if (content_size > 0)
	    {
	      num_packets++;
	    }
	  SET_ALLOC_ERR_AND_READ_EXPECTED_PACKETS (&error, rc, num_packets);

	}
    }


#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_request_finished (request, replysize + *recvbuffer_size +
			      content_size + packed_desc_size);
    }
#endif /* HISTO */

  return error;
}

/*
 * net_client_request_recv_stream -
 *
 * return:
 *
 *   request(in):
 *   argbuf(in):
 *   argsize(in):
 *   replybuf(in):
 *   replybuf_size(in):
 *   databuf(in):
 *   datasize(in):
 *   outfp(in):
 *
 * Note:
 */
int
net_client_request_recv_stream (int request, char *argbuf, int argsize,
				char *replybuf, int replybuf_size,
				char *databuf, int datasize, FILE * outfp)
{
  unsigned int rc;
  int size;
  int error;
  char *reply;
  char *send_argbuffer;
  int send_argsize;
  char *recv_replybuf;
  int recv_replybuf_size;
  char reply_streamdata[100];
  int reply_streamdata_size = 100;
  int file_size;

  error = NO_ERROR;

  send_argsize = argsize + OR_INT_SIZE;
  recv_replybuf_size = replybuf_size + OR_INT_SIZE;

  send_argbuffer = (char *) malloc (send_argsize);
  if (send_argbuffer == NULL)
    {
      error = ER_NET_CANT_ALLOC_BUFFER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

  or_pack_int (send_argbuffer, reply_streamdata_size);

  if (argsize > 0)
    {
      memcpy (send_argbuffer + OR_INT_SIZE, argbuf, argsize);
    }

  recv_replybuf = (char *) malloc (recv_replybuf_size);
  if (recv_replybuf == NULL)
    {
      free_and_init (send_argbuffer);
      error = ER_NET_CANT_ALLOC_BUFFER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      free_and_init (send_argbuffer);
      free_and_init (recv_replybuf);
      error = ER_NET_SERVER_CRASHED;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      histo_add_entry (request, send_argsize + datasize);
    }
#endif /* HISTO */

  rc = css_send_req_to_server (net_Server_host, request, send_argbuffer,
			       send_argsize, databuf, datasize,
			       recv_replybuf, recv_replybuf_size);
  if (rc == 0)
    {
      error = set_server_error (css_Errno);
      goto end;
    }
  else
    {
      error = css_receive_data_from_server (rc, &reply, &size);
      if (error != NO_ERROR)
	{
	  error = set_server_error (error);
	  goto end;
	}
      else
	{
	  error = COMPARE_SIZE_AND_BUFFER (&recv_replybuf_size, size,
					   &recv_replybuf, reply);
	}

      /* Get total size of file to transfered */
      or_unpack_int (recv_replybuf, &file_size);

      if (replybuf)
	{
	  memcpy (replybuf, recv_replybuf + OR_INT_SIZE,
		  recv_replybuf_size - OR_INT_SIZE);
	}

#if defined(HISTO)
      if (net_Histo_setup)
	{
	  histo_request_finished (request, recv_replybuf_size + file_size);
	}
#endif /* HISTO */

      while (file_size > 0)
	{
	  css_queue_receive_data_buffer (rc, reply_streamdata,
					 reply_streamdata_size);
	  error = css_receive_data_from_server (rc, &reply, &size);
	  if (error != NO_ERROR)
	    {
	      error = set_server_error (error);
	      goto end;
	    }
	  else
	    {
	      if (reply != reply_streamdata)
		{
		  error = ER_NET_UNUSED_BUFFER;
		  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
		  break;
		}
	      if (size > reply_streamdata_size)
		{
		  error = ER_NET_DATASIZE_MISMATCH;
		  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE,
			  error, 2, reply_streamdata_size, size);
		  break;
		}
	      file_size -= size;
	      fwrite (reply_streamdata, 1, size, outfp);
	    }
	}
    }

end:

  free_and_init (send_argbuffer);
  free_and_init (recv_replybuf);

  return (error);
}

/*
 * net_client_ping_server -ping the server
 *
 * return:
 */

int
net_client_ping_server (int client_val, int *server_val)
{
  OR_ALIGNED_BUF (OR_INT_SIZE) a_request;
  char *request = OR_ALIGNED_BUF_START (a_request);
  OR_ALIGNED_BUF (OR_INT_SIZE) a_reply;
  char *reply = OR_ALIGNED_BUF_START (a_reply);
  int eid, error, reply_size;

  error = NO_ERROR;
  if (net_Server_host[0] == '\0' || net_Server_name[0] == '\0')
    {
      error = ER_NET_NO_SERVER_HOST;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

  /* you can envelope something useful into the request */
  or_pack_int (request, client_val);
  eid = css_send_request_to_server_with_buffer (net_Server_host,
						NET_SERVER_PING,
						request, OR_INT_SIZE,
						reply, OR_INT_SIZE);
  if (eid == 0)
    {
      error = ER_NET_CANT_CONNECT_SERVER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2, net_Server_name,
	      net_Server_host);
      return error;
    }

  error = css_receive_data_from_server (eid, &reply, &reply_size);
  if (error)
    {
      error = ER_NET_SERVER_DATA_RECEIVE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

  /* you can get something useful from the server */
  if (server_val)
    {
      or_unpack_int (reply, server_val);
    }

  return error;
}

/*
 * net_client_ping_server_with_handshake -
 *
 * return:
 */
int
net_client_ping_server_with_handshake (void)
{
  char *client_rel_string, *server_rel_string = NULL,
    *server_handshake = NULL, *ptr;
  int error = NO_ERROR;
  OR_ALIGNED_BUF (REL_MAX_RELEASE_LENGTH) a_request;
  char *request = OR_ALIGNED_BUF_START (a_request);
  OR_ALIGNED_BUF (REL_MAX_RELEASE_LENGTH + (OR_INT_SIZE * 2) + 32) a_reply;
  char *reply = OR_ALIGNED_BUF_START (a_reply), *reply_ptr;
  int eid, reply_size, request_size, server_capabilities, server_bit_platform;

  if (net_Server_host[0] == '\0' || net_Server_name[0] == '\0')
    {
      error = ER_NET_NO_SERVER_HOST;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

  client_rel_string = (char *) rel_release_string ();
  or_pack_string (request, client_rel_string);
  request_size = or_packed_string_length (client_rel_string);
  reply_size = REL_MAX_RELEASE_LENGTH + (OR_INT_SIZE * 2);
  reply_size += 32;		/* room for handshake string size; for backward compatibility */

  eid = css_send_request_to_server_with_buffer (net_Server_host,
						NET_SERVER_PING_WITH_HANDSHAKE,
						request, request_size,
						reply, reply_size);
  if (eid == 0)
    {
      error = ER_NET_CANT_CONNECT_SERVER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2, net_Server_name,
	      net_Server_host);
      return error;
    }

  reply_ptr = reply;
  error = css_receive_data_from_server (eid, &reply_ptr, &reply_size);
  if (error)
    {
      error = ER_NET_SERVER_DATA_RECEIVE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }
  if (reply != reply_ptr)
    {
      error = ER_NET_UNUSED_BUFFER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

  ptr = or_unpack_string_nocopy (reply, &server_rel_string);
  ptr = or_unpack_string_nocopy (ptr, &server_handshake);	/* for backward compatibility */
  ptr = or_unpack_int (ptr, &server_capabilities);
  ptr = or_unpack_int (ptr, &server_bit_platform);

  if (!net_check_client_server_compatibility (server_rel_string,
					      client_rel_string))
    {
      error = ER_NET_DIFFERENT_RELEASE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2,
	      server_rel_string, client_rel_string);
      goto cleanup;
    }

  if (server_bit_platform != rel_bit_platform ())
    {
      error = ER_NET_DIFFERENT_BIT_PLATFORM;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2, server_bit_platform,
	      rel_bit_platform ());
      goto cleanup;
    }

  record_server_capabilities (server_capabilities);

cleanup:

  return error;
}

/*
 * net_client_shutdown_server -
 *
 * return:
 *
 * Note: Sends the server shutdown request to the server.
 *    This is not used and I'm not sure if it even works.
 *    Need to be careful that we don't expect a reply here.
 */
void
net_client_shutdown_server (void)
{
  css_send_request_to_server (net_Server_host, NET_SERVER_SHUTDOWN, NULL, 0);
}

/*
 * net_client_init -
 *
 * return: error code
 *
 *   dbname(in): server name
 *   hostname(in): server host name
 *
 * Note: This is called during startup to initialize the client side
 *    communications. It sets up CSS and verifies connection with the server.
 */
int
net_client_init (const char *dbname, const char *hostname)
{
  int error = NO_ERROR;

  /* don't really need to do this every time but bruce says its ok -
     we probably need to guarentee that a css_terminate is always
     called before this */
  error = css_client_init (PRM_TCP_PORT_ID, NULL, dbname, hostname);
  if (error != NO_ERROR)
    {
      goto end;
    }

  /* since urgent_message_handler() doesn't do anything yet, just
     use the default handler provided by css which writes things
     to the system console */

  /* set our host/server names for further css communication */
  if ((hostname != NULL) && ((strlen (hostname) + 1) < MAX_SERVER_HOST_NAME))
    {
      strcpy (net_Server_host, hostname);
      if ((dbname != NULL) && ((strlen (dbname) + 1) < MAX_SERVER_NAME))
	{
	  strcpy (net_Server_name, dbname);
	}
      else
	{
	  error = ER_NET_INVALID_SERVER_NAME;
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 1, dbname);
	}
    }
  else
    {
      error = ER_NET_INVALID_HOST_NAME;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 1, hostname);
    }

  if (error == NO_ERROR)
    {
      /* ping to validate availability */
      error = net_client_ping_server_with_handshake ();
    }

  /* On error, flush any state that may have been initialized by css.
   * This is important for the PC's since we must shutdown Winsock
   * after it has been opened by css_client_init.
   */
end:
  if (error)
    {
      css_terminate (false);
    }

  return (error);
}

/*
 * net_cleanup_client_queues -
 *
 * return:
 *
 * Note:
 */
void
net_cleanup_client_queues (void)
{
  if (net_Server_host[0] != '\0' && net_Server_name[0] != '\0')
    {
      css_cleanup_client_queues (net_Server_host);
    }
}

/*
 * net_client_final -
 *
 * return: error cod
 *
 * Note: This is called during shutdown to close the communication interface.
 */
int
net_client_final (void)
{
  css_terminate (false);
  return (NO_ERROR);
}

/*
 * net_client_send_data -
 *
 * return:
 *
 *   host(in):
 *   rc(in):
 *   databuf(in):
 *   datasize(in):
 *
 * Note: Send a data buffer to the server.
 */
int
net_client_send_data (char *host, unsigned int rc,
		      char *databuf, int datasize)
{
  int error;

  if (databuf != NULL)
    {
      error = css_send_data_to_server (host, rc, databuf, datasize);
      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}
    }

  return NO_ERROR;
}

/*
 * net_client_receive_action -
 *
 * return:
 *
 *   rc(in):
 *   action(in):
 *
 * Note:
 */
int
net_client_receive_action (int rc, int *action)
{
  int size;
  int error;
  char *reply;
  int replysize = OR_INT_SIZE;

  error = NO_ERROR;
  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      error = ER_NET_SERVER_CRASHED;
    }
  else
    {
      error = css_receive_data_from_server (rc, &reply, &size);
      if (error != NO_ERROR)
	{
	  return set_server_error (error);
	}

      if (size != replysize)
	{
	  error = ER_NET_DATASIZE_MISMATCH;
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2, replysize,
		  size);
	  replysize = size;
	  return set_server_error (error);
	}
      or_unpack_int (reply, action);
      free_and_init (reply);
    }

  return (error);
}
