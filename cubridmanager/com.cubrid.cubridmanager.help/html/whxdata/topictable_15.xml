<?xml version="1.0" encoding="UTF-8"?>
<ck><di ky="601" rd="syntax/syntax_tran_isolation_handledirty.htm|CUBRID에서 더티 인스턴스(dirty instances)를 다루는 방법" ct=" CUBRID에서 더티 인스턴스(dirty instances)를 다루는 방법  CUBRID는 다양한 상황에서 워크스페이스(클라이언트)의 더티 인스턴스를 데이터베이스(서버)로 ..."/><di ky="602" rd="syntax/syntax_tran_isolation_intro.htm|개요" ct=" 개요  CUBRID는 트랜잭션의 격리 수준(isolation level)을 지정하여 덜 제한적인 일관성(consistency)으로 트랜잭션을 수행하도록 한다. 트랜잭션의  ..."/><di ky="603" rd="syntax/syntax_tran_isolation_readcom.htm|READ COMMITTED CLASS with READ COMMITTED INSTANCES" ct=" READ COMMITTED CLASS with READ COMMITTED INSTANCES  이 격리 수준은 트랜잭션이 다른 트랜잭션에서 수정 중인 객체(클래스 또는 인스 ..."/><di ky="604" rd="syntax/syntax_tran_isolation_readuncom.htm|READ COMMITTED CLASS with READ UNCOMMITTED INSTANCES" ct=" READ COMMITTED CLASS with READ UNCOMMITTED INSTANCES  이 격리 수준은 트랜잭션이 다른 트랜잭션에서 수정 중인 클래스를 읽지 못하 ..."/><di ky="605" rd="syntax/syntax_tran_isolation_repeatable.htm|REPEATABLE READ CLASS with REPEATABLE READ INSTANCES" ct=" REPEATABLE READ CLASS with REPEATABLE READ INSTANCES  이 격리 수준에서는 더티 읽기, 반복 불가능한 읽기가 발생하지 않지만, 유 ..."/><di ky="606" rd="syntax/syntax_tran_isolation_repeatcom.htm|REPEATABLE READ CLASS with READ COMMITTED INSTANCES" ct=" REPEATABLE READ CLASS with READ COMMITTED INSTANCES  이 격리 수준은 트랜잭션이 다른 트랜잭션에서 수정 중인 객체를 읽지 못하게  ..."/><di ky="607" rd="syntax/syntax_tran_isolation_repeatuncom.htm|REPEATABLE READ CLASS with READ UNCOMMITTED INSTANCES" ct=" REPEATABLE READ CLASS with READ UNCOMMITTED INSTANCES  이 격리 수준은 트랜잭션이 다른 트랜잭션에서 수정 중인 클래스를 읽지 못 ..."/><di ky="608" rd="syntax/syntax_tran_isolation_serializable.htm|SERIALIZABLE" ct=" SERIALIZABLE  이 격리 수준에서는 모든 동시성 관련 문제들, 즉 더티 읽기, 반복 불가능한 읽기, 유령 읽기 등이 발생하지 않는다.  다음과 같은 규칙이 적 ..."/><di ky="609" rd="syntax/syntax_tran_isolation_setting.htm|격리 수준 설정" ct=" 격리 수준 설정  설명  isolation_level  시스템 매개변수와  SET TRANSACTION  문으로 원하는 격리 수준을 설정할 수 있다. 처음 CUBRID ..."/><di ky="610" rd="syntax/syntax_tran_isolation_unsupported.htm|지원하지 않는 격리 수준 조합" ct=" 지원하지 않는 격리 수준 조합  비록  SET TRANSACTION ISOLATION LEVEL  구문이 다른 조합을 정의할 수 있도록 하더라도 아래의 조합은 허용하지 않 ..."/><di ky="611" rd="syntax/syntax_tran_isolation_update.htm|UPDATE INCONSISTENCY" ct=" UPDATE INCONSISTENCY  이 격리 수준에서는 커밋되지 않은 갱신을 잃어버릴 수 있다. 이것은 트랜잭션이 끝나기 전에 데이터를 커밋하기 때문에 트랜잭션을 복구 ..."/><di ky="612" rd="syntax/syntax_tran_lock_deadlocks.htm|트랜잭션 교착 상태" ct=" 트랜잭션 교착 상태  둘 또는 그 이상의 트랜잭션이 서로 끝나기를(커밋 또는 롤백) 기다리는 상황이 발생할 수 있다. 이 경우 트랜잭션이 서로 진행을 못하게 하기 때문에  ..."/><di ky="613" rd="syntax/syntax_tran_lock_determine.htm|잠금 허용 여부 결정" ct=" 잠금 허용 여부 결정  CUBRID는 수행되는 연산에 기초하여 획득할 필요가 있는 잠금을 결정한다. 사용자는 결코 획득할 잠금의 유형을 CUBRID에 지시할 수 없다. 잠 ..."/><di ky="614" rd="syntax/syntax_tran_lock_granularity.htm|단위 잠금" ct=" 단위 잠금  CUBRID는 잠금의 개수를 줄이기 위해서 단위 잠금(granularity locking) 프로토콜을 사용한다. 단위 잠금 프로토콜에서는 데이터베이스가 잠금  ..."/><di ky="615" rd="syntax/syntax_tran_lock_intro.htm|개요" ct=" 개요  CUBRID가 사용하는 2단계 잠금 프로토콜(2-phase locking protocol)에서는, 충돌하는 연산이 동시에 수행되지 않도록 하기 위해, 트랜잭션은 객 ..."/><di ky="616" rd="syntax/syntax_tran_lock_timeouts.htm|트랜잭션 타임아웃" ct=" 트랜잭션 타임아웃  CUBRID는 잠금의 타임아웃 기능을 제공한다. 응용 프로그램은 잠금을 기다리는 최소한의 시간을 CUBRID에 알려줄 수 있는데,  lock_timeo ..."/><di ky="617" rd="syntax/syntax_tran_recovery_intro.htm|개요" ct=" 개요  CUBRID에서 복구 프로세스를 사용하면 소프트웨어 또는 하드웨어에 오류가 발생하더라도 데이터베이스에는 영향을 미치지 않도록 할 수 있다. CUBRID에서 모든 읽 ..."/><di ky="618" rd="syntax/syntax_tran_recovery_restart.htm|데이터베이스 재구동" ct=" 데이터베이스 재구동  CUBRID는 시스템과 매체(디스크)에 오류가 발생했을 때 커밋되었거나 커밋되지 않은 트랜잭션을 복구하기 위해 로그 볼륨/파일과 데이터베이스 백업을  ..."/><di ky="619" rd="syntax/syntax_tran_tran_commit.htm|트랜잭션 커밋" ct=" 트랜잭션 커밋  설명  데이터베이스에서 일어난 갱신들은  COMMIT WORK  문이 주어지기 전까지 영구히 저장되지 않는다. &quot;영구히(permanently)&quot; 저장된 ..."/><di ky="620" rd="syntax/syntax_tran_tran_intro.htm|개요" ct=" 개요  데이터베이스 트랜잭션은 CUBRID 질의문을 일관성(다중 사용자 환경에서 유효한 결과를 만들어내는 것)과 복구(시스템 실패와 같은 어떤 장애에도 커밋된 트랜잭션의  ..."/><di ky="621" rd="syntax/syntax_tran_tran_rollback.htm|트랜잭션 롤백" ct=" 트랜잭션 롤백  설명  ROLLBACK WORK  문은 마지막 트랜잭션 이후의 모든 데이터베이스의 갱신을 제거한다.  WORK  키워드는 생략 가능하다. 이것은 데이터 ..."/><di ky="622" rd="syntax/syntax_tran_tran_savepoint.htm|세이브포인트와 부분 롤백" ct=" 세이브포인트와 부분 롤백  설명  세이브포인트(savepoint)는 트랜잭션이 진행되는 중에 수립되는데, 트랜잭션에 의해 수행되는 데이터베이스 갱신을 세이브포인트 지점 ..."/><di ky="623" rd="syntax/syntax_trigger_app.htm|트리거를 이용한 응용" ct=" 트리거를 이용한 응용  여기에서는 데모 데이터베이스에 있는 트리거 정의에 대해 알아본다.  demodb 데이터베이스에 생성되어 있는 트리거는 그리 복잡하지는 않지만 C ..."/><di ky="624" rd="syntax/syntax_trigger_create_action.htm|트리거 실행 영역" ct=" 트리거 실행 영역  설명  트리거 실행 영역은 트리거의 조건 영역이 참이거나 조건 영역이 생략된 경우 수행될 내용을 기술하는 영역이다.  실행 영역 절에 특정 시점 ..."/><di ky="625" rd="syntax/syntax_trigger_create_combi.htm|이벤트 타입과 대상 조합" ct=" 이벤트 타입과 대상 조합  설명  트리거를 호출하는 데이터베이스 이벤트는 트리거 이벤트 타입과 트리거 정의 내의 이벤트 대상에 의해 식별된다. 다음은 트리거 이벤트 타 ..."/><di ky="626" rd="syntax/syntax_trigger_create_cond.htm|트리거 조건 영역" ct=" 트리거 조건 영역  설명  트리거를 정의할 때 조건 영역을 정의하여 트리거의 수행 영역에 대한 수행 여부를 결정한다.     트리거 조건 영역이 기술된다면, 참 ..."/><di ky="627" rd="syntax/syntax_trigger_create_correlation.htm|상관명(correlation name)" ct=" 상관명(correlation name)  트리거를 정의할 때 상관명을 사용하여 대상 테이블의 컬럼 값에 접근할 수 있다. 상관명은 실제적으로 트리거를 부르는 데이터베이스  ..."/><di ky="628" rd="syntax/syntax_trigger_create_etype.htm|트리거 이벤트 타입" ct=" 트리거 이벤트 타입   설명   인스턴스 이벤트(instance event) : 인스턴스 이벤트는 이벤트 연산의 단위가 인스턴스인 이벤트 타입을 말한다. 인스턴스  ..."/><di ky="629" rd="syntax/syntax_trigger_create_event.htm|이벤트 시점" ct=" 이벤트 시점  설명  트리거의 조건 영역과 실행 영역이 실행되는 시점을 지정한다. 이벤트 시점의 종류에는  BEFORE ,  AFTER ,  DEFERRED 가 있다. ..."/><di ky="630" rd="syntax/syntax_trigger_create_guideline.htm|트리거 정의를 위한 가이드라인" ct=" 트리거 정의를 위한 가이드라인  트리거 정의로 다양하고 강력한 기능을 만들 수 있다. 트리거를 생성하기 전에 다음과 같은 정의 사항을 고려해야 한다:   트리거의  ..."/><di ky="631" rd="syntax/syntax_trigger_create_syntax.htm|CREATE TRIGGER (구문)" ct=" CREATE TRIGGER (구문)  설명  트리거는  CREATE TRIGGER  구문에 트리거 대상, 실행 조건과 수행할 내용을 정의하여 생성한다.  구문  ..."/><di ky="632" rd="syntax/syntax_trigger_create_target.htm|트리거 이벤트 대상" ct=" 트리거 이벤트 대상  설명  이벤트 대상은 트리거가 호출되기 위한 대상을 지정할 때 쓰인다. 트리거 이벤트의 대상은 테이블명 혹은 테이블명과 컬럼명으로 지정할 수 있으 ..."/><di ky="633" rd="syntax/syntax_trigger_create_ttype.htm|트리거 타입" ct=" 트리거 타입  사용자 트리거(User Trigger)   데이터베이스의 특정 사용자와 관련된 트리거를 사용자 트리거(user trigger)라고 한다.  사용자 ..."/><di ky="634" rd="syntax/syntax_trigger_debug_def.htm|정의와 예제" ct=" 정의와 예제  설명  트리거를 정의한 후에는 트리거가 의도한 대로 동작하는지 검사하는 것이 좋다. 종종 트리거가 기대했던 것보다 처리하는데 오랜 시간이 걸리는 경우가  ..."/><di ky="635" rd="syntax/syntax_trigger_debug_limit.htm|중첩된 트리거 제한" ct=" 중첩된 트리거 제한  설명  SET TRIGGER  문의  MAXIMUM DEPTH  키워드를 이용하여 단계적으로 발동되는 트리거 수를 제한할 수 있다.  이를 이 ..."/></ck>