
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="layout-height" content="25810" />
<meta name="layout-width" content="1072" />
<title>READ COMMITTED CLASS with READ UNCOMMITTED INSTANCES</title>
<link href="../nhelp.css" rel="Stylesheet" type="text/css" />
 <meta name="generator" content="Adobe RoboHelp 8" />
<script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
	origWidth = innerWidth;
	origHeight = innerHeight;
	onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
-->
</style>
<script type="text/javascript" language="javascript1.2" src="../whmsg.js"></script>
<script type="text/javascript" language="javascript" src="../whver.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whproxy.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whutils.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whlang.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whtopic.js"></script>

</head>
<body><script type="text/javascript" language="javascript1.2">//<![CDATA[
<!--
if (window.gbWhTopic)
{
	var strUrl = document.location.href;
	var bc = 0;
	var n = strUrl.toLowerCase().indexOf("bc-");
	if(n != -1)
	{
		document.location.href = strUrl.substring(0, n);
		bc = strUrl.substring(n+3);
	}

	if (window.addTocInfo)
	{
	addTocInfo("CUBRID SQL 설명서\n트랜잭션 관리\n트랜잭션 격리 수준\nREAD COMMITTED CLASS with READ UNCOMMITTED INSTANCES");
         if(strUrl.toLowerCase().indexOf("/help/")==-1){

    addButton("show",BTN_TEXT,"Show","","","","",0,0,"","","");

    }


	}
	if (window.writeBtnStyle)
		writeBtnStyle();

	if (window.writeIntopicBar)
		writeIntopicBar(1);if(strUrl.toLowerCase().indexOf("/help/")==-1){

         document.write("<p style=\"text-align:left\"> ");

AddMasterBreadcrumbs("../index.htm", "", "&nbsp;&gt;&nbsp;", "홈", "../cubrid.htm");

document.write("<a href=\"syntax.htm\">CUBRID SQL 설명서<\/a> &nbsp;&gt;&nbsp; <a href=\"syntax_tran_intro.htm\">트랜잭션 관리<\/a> &nbsp;&gt;&nbsp; <a href=\"syntax_tran_isolation_intro.htm\">트랜잭션 격리 수준<\/a> &nbsp;&gt;&nbsp; READ COMMITTED CLASS with READ UNCOMMITTED INSTANCES<\/p>");}


	if (window.setRelStartPage)
	{
	setRelStartPage("../index.htm");

		autoSync(1);
		sendSyncInfo();
		sendAveInfoOut();
	}
}
else
	if (window.gbIE4)
		document.location.reload();

//-->
//]]></script>
<h4>READ COMMITTED CLASS with READ UNCOMMITTED INSTANCES</h4>
<p>이 격리 수준은 트랜잭션이 다른 트랜잭션에서 수정 중인&#160;클래스를 읽지 못하게&#160;하며, 이후에 갱신되거나 롤백될 수도 있는&#160;더티 인스턴스를 읽도록 허용한다. 트랜잭션은 클래스와 인스턴스에 대한 읽기가 반복 불가능(non-repeatable read)할 수도 있다. 이것은 트랜잭션이 동일한 클래스를 두 번 읽게 되면 다른 두 커밋된 값을 읽을 수 있고, 동일한 인스턴스를 두 번 읽게 되면 커밋되었거나 그렇지 않은 서로 다른 두 값을 읽을 수 있음을 의미한다. 커밋되지 않은 인스턴스는 그 인스턴스를 갱신하는 트랜잭션에 의해 롤백될 수 있는데, 그 이유는 다른 트랜잭션이 두 번 읽는 간격 동안에 객체를 갱신하기 때문이다. 마찬가지로,&#160;한 질의가 두 번 수행되면&#160;두 수행 결과가 다를 수 있다. 이것은 두 질의가 수행되는 간격 동안에 커밋되거나 그렇지 않은&#160;인스턴스에 대한 삽입, 갱신, 삭제가 있을 수 있기 때문이다. 질의되는 클래스는 더 이상 존재하지 않을 수도 있고 속성 일부는 추가되었거나 삭제되었을 수도 있다. <span class="keyword">REPEATABLE READ</span> 격리 수준에서는 클래스에 대한 갱신은 불가능한데, 그 이유는 트랜잭션이 끝까지 클래스에 대한 잠금을 가지고 있기 때문이다.</p>
<p>아래는 이 격리 수준의 규칙이다.</p>
<ul>
<li>트랜잭션은 다른 트랜잭션에서 수정 중인&#160;객체를 덮어쓰지 않는다.</li>
<li>트랜잭션은 트랜잭션이 끝날 때까지 객체를 커밋하지 않는다.</li>
<li>트랜잭션은 다른 트랜잭션에서 수정 중인&#160;클래스를 읽지 않는다. 이 규칙은 인스턴스에는 적용되지 않는다.</li>
</ul>
<p>이 격리 수준은 배타 잠금에 대해서 2단계 잠금을 한다. 하지만 공유 잠금은 인스턴스에 대해 획득할 수 없고 클래스에 대한 공유 잠금 또는 의도 공유 잠금은 클래스가 읽혀진 후 곧바로 해제된다.</p>
<h6>예제</h6>
<p>한 트랜잭션은 인스턴스를 삽입하고 클래스를 갱신하며 다른 클래스는 다양한 관점에서 클래스에 질의를 한다. 트랜잭션 T1은 임의의 격리 수준을 가지며 트랜잭션 T2는 <span class="keyword">READ COMMITTED CLASS</span> with <span class="keyword">READ UNCOMMITTED INSTANCES</span> 격리 수준을 가진다. &#160;이 예제에서는 partition2 클래스가 이전에 존재하지 않을 것으로 가정하고 생성한다.</p>
<ol>
<li>트랜잭션 T1은 partition2 클래스를 생성하고 인스턴스를 삽입한다. 트랜잭션 T1이 커밋되자마자 CUBRID는 트랜잭션 T1이 가지고 있던 잠금을 해제한다. 트랜잭션 T2는 partition2 클래스에 질의한다.
<ol>
<li>User1 (T1):</li>
<li class="code">SET TRANSACTION ISOLATION LEVEL READ COMMITTED CLASS, READ UNCOMMITTED INSTANCES;<br />
;xrun<br />
;autocommit off<br />
create class participant2 (host_year integer, nation_code char(3));<br />
insert into participant2 (host_year, nation_code) values (2008, 'AUS');<br />
commit work;<br />
;xrun<br />
<span class="var">1 rows inserted.</span></li>
<li>User2 (T2):</li>
<li class="code">SET TRANSACTION ISOLATION LEVEL READ COMMITTED CLASS, READ UNCOMMITTED INSTANCES;<br />
;xrun<br />
;autocommit off<br />
select host_year, nation_code from participant2;<br />
;xrun<br />
<span class="var">=== &lt;Result of SELECT Command in Line 2&gt; ===<br />
&#160;&#160;&#160;&#160;host_year &#160;nation_code<br />
===================================<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2008 &#160;'AUS'<br />
1 rows selected.</span></li>
</ol>
</li>
<li>트랜잭션 T1은 participant2 클래스에 또 하나의 인스턴스를 삽입한다. 트랜잭션 T2가 participant2 클래스에 질의했을 때는 커밋된 첫 번째 인스턴스만 보이게 되는데, 그 이유는 이 예제에서 두 번째 인스턴스가 데이터베이스로 출력되지 않았기 때문이다.
<ol>
<li>User1 (T1):</li>
<li class="code">insert into participant2 (host_year, nation_code) values (2004, 'FRA');<br />
;xrun<br />
<span class="var">1 rows inserted.</span></li>
<li>User2 (T2):</li>
<li class="code">select * from participant2;<br />
;xrun<br />
<span class="var">=== &lt;Result of SELECT Command in Line 1&gt; ===<br />
&#160;&#160;&#160;&#160;host_year &#160;nation_code<br />
===================================<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2008 &#160;'AUS'<br />
1 rows selected.<br />
1 command(s) successfully processed.</span></li>
</ol>
</li>
<li>트랜잭션 T1은 participant2 클래스를 갱신하고 gold 속성을 추가한다. 이 때 트랜잭션 T2가 이 클래스에 질의를 하면 대기 상태가 되는데, 이는&#160;<span class="keyword">ALTER</span> 문 때문이다. 이는 다른 격리 수준에서도 가능한데,&#160;그 이유는 트랜잭션의 끝까지 클래스에 대한 잠금을 유지하기 때문이다.
<ol>
<li>User1 (T1):</li>
<li class="code">alter class participant2<br />
add attribute gold integer;<br />
;xrun<br />
<span class="var">1 command(s) successfully processed.</span></li>
<li>User2 (T2):</li>
<li class="code">select * from participant2;<br />
;xrun</li>
</ol>
</li>
<li>트랜잭션 T1은 participant2 클래스에 gold 속성을 포함한 또 하나의 인스턴스를 삽입한다. 트랜잭션 T1이 연산을 커밋하고 트랜잭션 T2가 다시 진행된다. 트랜잭션 T2는 완전히 다른 스키마(클래스)를 보게 됨을 주의해야 한다.
<ol>
<li>User1 (T1):</li>
<li class="code">insert into participant2 (host_year, nation_code, gold)<br />
values (2012, 'KOR', 20);<br />
commit work;<br />
;xrun<br />
<span class="var">1 command(s) successfully processed.</span></li>
<li>User2 (T2):</li>
<li class="code"><span class="var">=== &lt;Result of SELECT Command in Line 1&gt; ===<br />
&#160;&#160;&#160;&#160;host_year &#160;nation_code &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gold<br />
======================================<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2008 &#160;'AUS' &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NULL<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2004 &#160;'FRA' &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NULL<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2012 &#160;'KOR' &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20</span><br />
<span class="var">3 rows selected.</span></li>
</ol>
</li>
</ol>
<script type="text/javascript" language="javascript1.2">//<![CDATA[
<!--
if (window.writeIntopicBar)
	writeIntopicBar(0);


highlightSearch();
//-->
//]]></script>
</body>
</html>
