
<html>
<head>
 <meta name="generator" content="Adobe RoboHelp 8" />
<title>클래스에 정의된 메소드</title>
<link type="text/css" rel="stylesheet" href="../nhelp.css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
	origWidth = innerWidth;
	origHeight = innerHeight;
	onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
-->
</style>
<script type="text/javascript" language="javascript1.2" src="../whmsg.js"></script>
<script type="text/javascript" language="javascript" src="../whver.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whproxy.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whutils.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whlang.js"></script>
<script type="text/javascript" language="javascript1.2" src="../whtopic.js"></script>

</head>
<body><script type="text/javascript" language="javascript1.2">//<![CDATA[
<!--
if (window.gbWhTopic)
{
	var strUrl = document.location.href;
	var bc = 0;
	var n = strUrl.toLowerCase().indexOf("bc-");
	if(n != -1)
	{
		document.location.href = strUrl.substring(0, n);
		bc = strUrl.substring(n+3);
	}

	if (window.addTocInfo)
	{
	addTocInfo("CUBRID SQL 설명서\n멀티미디어 데이터 관리\nglo 클래스\n클래스에 정의된 메소드");
         if(strUrl.toLowerCase().indexOf("/help/")==-1){

    addButton("show",BTN_TEXT,"Show","","","","",0,0,"","","");

    }


	}
	if (window.writeBtnStyle)
		writeBtnStyle();

	if (window.writeIntopicBar)
		writeIntopicBar(1);if(strUrl.toLowerCase().indexOf("/help/")==-1){

         document.write("<p style=\"text-align:left\"> ");

AddMasterBreadcrumbs("../index.htm", "", "&nbsp;&gt;&nbsp;", "홈", "../cubrid.htm");

document.write("<a href=\"syntax.htm\">CUBRID SQL 설명서<\/a> &nbsp;&gt;&nbsp; <a href=\"syntax_mm_glo_intro.htm\">멀티미디어 데이터 관리<\/a> &nbsp;&gt;&nbsp; <a href=\"syntax_mm_glo_intro.htm\">glo 클래스<\/a> &nbsp;&gt;&nbsp; 클래스에 정의된 메소드<\/p>");}


	if (window.setRelStartPage)
	{
	setRelStartPage("../index.htm");

		autoSync(1);
		sendSyncInfo();
		sendAveInfoOut();
	}
}
else
	if (window.gbIE4)
		document.location.reload();

//-->
//]]></script>
<h4>클래스에 정의된 메소드</h4>
<ul>
<li><a href="#desc">설명</a></li>
<li><a href="#class">glo 클래스 메소드</a></li>
<li><a href="#instance">glo 인스턴스 메소드</a></li>
</ul>
<h5><a name="desc" id="desc">설명</a></h5>
<p><span class="keyword">glo</span> 클래스는 CUBRID의 <span class="keyword">CALL METHOD</span> 문으로 호출하여 사용한다. <span class="keyword">glo</span> 클래스에서는 클래스 메소드와 인스턴스 메소드가 운영된다.</p>
<p><span class="keyword">glo</span> 클래스에 정의된 두 메소드는 클래스의 인스턴스보다는 클래스 객체를 운영하는 데에&#160;사용된다.</p>
<p><span class="keyword">glo</span> 인스턴스 메소드는 <span class="keyword">glo</span> 데이터를 조작하기 위한 접근, 갱신 기능을 제공한다. 메소드의 인수(데이터 버퍼 등)는 CSQL 프로세서에서 명시할&#160;수 없기 때문에 대부분의 인스턴스 메소드는 Java나 C와 같은 프로그래밍 언어 인터페이스에서 사용한다.</p>
<h5><a name="class" id="class">glo 클래스 메소드</a></h5>
<h6>new_fbo 클래스 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 인스턴스의 FBO (File Based Object) 타입을 생성한다. 메소드의 인수 값은 단일 문자열의 파일 경로이다. <span class="keyword">new_fbo</span>( ) 메소드가 성공적으로 수행되면, 요청한 클래스의 새로운 인스턴스가 반환된다. FBO를 생성하기 위한 <span class="keyword">new_fbo</span>( ) 메소드의 문법은 다음과 같다.</p>
<p class="syntax"><span class="keyword">CALL new_fbo</span>(<span class="var">:pathname</span>)<br />
&#160;&#160;&#160;&#160;<span class="keyword">ON CLASS glo INTO</span> <span class="var">:write_object</span>;</p>
<p><span class="keyword">new_fbo</span>( ) 클래스 메소드의 파일 경로명으로 환경 변수를 사용할 수도 있다. 따라서&#160;서로 다른 파일 시스템을 사용하는 클라이언트가 동일한 FBO에 접속하는 것도 가능하다.</p>
<p>예를 들어, 다음과 같이 FBO 파일 경로를 주고, 어떤 사용자는 FBO_ROOT의 값을 ”/usr/local”로 설정하고 다른 사용자는 ”/net/edsel/usr/local”로 설정할 수 있다.</p>
<p class="code">csql&gt;CALL new_fbo(’$FBO_ROOT/test/fbo1.txt’)<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ON CLASS glo INTO :fbo;</p>
<p>파일 경로는 CUBRID 환경 변수인 <span class="keyword">CUBRID_FBO_PREFIX</span>를 수정하여 사용할 수도 있다. <span class="keyword">CUBRID_FBO_PREFIX</span> 변수에 값을 설정하면 파일에 접근할 때 모든 FBO 파일 경로명 앞에 붙는다. 이미 파일 경로명에 환경 변수 참조가 포함되어 있으면, 변수의 값이 앞에 붙지 않는다.&#160;</p>
<p>예를 들어, 다음의 경우 FBO 파일에 접근하는 경로명은 "h:/remote1/usr/local/test/fbo1.txt"이다.</p>
<p class="code">%setenv CUBRID_FBO_PREFIX ”h:/remote1”<br />
csql&gt;CALL new_fbo(’/usr/local/test/fbo1.txt’)<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ON CLASS glo INTO :fbo;</p>
<p>NFS가 루트 파일 시스템이나 특정 서브 디렉토리에 마운트되고, 파일 경로명이 같다면, UNIX와 PC 클라이언트 모두 FBO의 내용에 접근할 수 있다. 위의 예에서, UNIX 시스템에서는 <span class="keyword">CUBRID_FBO_PREFIX</span> 변수에 값이 없고, PC에서는 변수에 NFS 볼륨 식별자 ”h:/remote1”를 명시해야 한다.</p>
<h6>new_lo 클래스 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 인스턴스의 LO (Large Object)를 생성한다. 함수 인수는 없다. <span class="keyword">new_lo</span>( ) 메소드는 원하는 클래스에 새로운 인스턴스를 반환한다.</p>
<p class="code">csql&gt;CALL new_lo()ON CLASS glo INTO :labeled_object;</p>
<h6>new_lo_import( ) 클래스 메소드</h6>
<p>이 메소드는 새로운 LO 인스턴스를 생성하거나 외부 파일로부터 그 내용을 초기화한다. 메소드 인수가 <span class="keyword">NULL</span>이면 비어있는 LO를 생성하고, 메소드 인수가 파일명을 포함하는 문자열이면 새로운 인스턴스 생성 후 해당 파일의 내용을 복사하게 된다.</p>
<p class="code">csql&gt;CALL new_lo_import(’./import_data.txt’)<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ON CLASS glo INTO :labeled_object;</p>
<h5><a name="instance" id="instance">glo 인스턴스 메소드</a></h5>
<h6>initialize_data( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 클래스의 새로운 인스턴스를 생성할 때마다 <span class="keyword">new_lo</span>( ) / <span class="keyword">new_fbo</span>( ) 클래스 메소드에 의해 자동으로 호출된다. <span class="keyword">glo</span> 클래스에서 기본 값으로 속성을 설정한다. <span class="keyword">glo</span> 클래스로부터 상속받은 클래스는 다른 기본 속성을 설정하거나, 다른 연산을 수행하도록 <span class="keyword">initialize_data</span>( ) 메소드를 재정의할 수 있다. 이 메소드는 일반적으로 사용자에 의해 호출되지 않으므로 인수가 없으면 무시된다.</p>
<h6>data_pos( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 인스턴스 메소드에 의해 사용되는 <span class="keyword">glo</span> 데이터 구역의 시작 위치를 반환한다. 다음은 <span class="keyword">glo</span> 인스턴스로부터 현재 위치를 반환한다.</p>
<p class="code">csql&gt;CALL data_pos() ON :labeled_object INTO :location;</p>
<h6>data_seek( ) 메소드</h6>
<p>이 메소드는 첫 번째 인수 값을 현재 위치로 설정한다. <span class="keyword">data_seek</span>( ) 메소드가 성공적으로 수행되면 새로운 위치가 반환된다. 다음은 <span class="keyword">data_seek</span>( ) 메소드를 사용하여 <span class="keyword">glo</span>&#160;데이터 구역에서 현재 위치를 42로 설정하는 예이다.</p>
<p class="code">csql&gt;CALL data_seek(42) ON :labeled_object;</p>
<h6>read_data( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span>로부터 사용자 데이터 버퍼로 데이터를 전송한다. 데이터는 <span class="keyword">glo</span> 데이터 내의 현재 위치부터 시작하여 읽게 된다. <span class="keyword">read_data</span>( ) 메소드의 인수는 두 개이다. 첫 번째 인수는 상수로 <span class="keyword">glo</span>로부터 읽어 들일 유닛의 개수를 명시하고, 두 번째 인수는 문자열로 데이터를 저장할 버퍼를 나타낸다. 메소드가 성공적으로 실행되면, 읽어 들인 실제 유닛의 개수와 <span class="keyword">glo</span>로부터 읽어 들인 데이터를 반환한다. 현재 위치는 자동적으로 갱신된다. 다음은 <span class="keyword">read_data</span>( ) 메소드를 사용한 C API 예이다. <span class="keyword">glo</span> 데이터의 현재 위치로부터 1024개의 유닛을 읽어 들이고, 문자 배열 버퍼에 데이터를 전송한다.</p>
<p class="code">...<br />
DB_INT32 rc, length = 1024;<br />
DB_OBJECT *read_object;<br />
char buffer[1024];<br />
DB_VALUE val1, val2, val3;<br />
...<br />
DB_MAKE_INTEGER(&amp;val1, length);<br />
DB_MAKE_VARCHAR(&amp;val2, DB_MAX_VARCHAR_PRECISION,&#160;buffer, length);<br />
rc = db_send(read_object, GLO_METHOD_READ, &amp;val3, &amp;val1, &amp;val2);<br />
...</p>
<p class="note"><span class="note-title">참고</span> <span class="keyword">read_data</span>( ) 메소드는 반환 값이 반드시 문자 버퍼에 저장되어야 하기 때문에 CSQL에서 사용되는 것이 지원되지 않는다. 따라서 JDBC나 C API를 통해서만 사용이 가능하다.</p>
<h6>write_data( ) 메소드</h6>
<p>이 메소드는 사용자 데이터 버퍼로부터 <span class="keyword">glo</span>로 데이터를 전송한다. 쓰기는 데이터가 존재하는 경우 <span class="keyword">glo</span> 데이터의 현재 위치로부터 덮어쓰기를 한다. <span class="keyword">write_data</span>( ) 메소드의 인수는 두 개이다. 첫 번째 인수는 <span class="keyword">glo</span>에 저장할 유닛의 수(정수)이고 두 번째 인수는&#160;저장될 데이터를 포함하고 있는 버퍼(문자열)이다. 실제 저장된 유닛의 개수를 반환하고, <span class="keyword">glo</span> 데이터 내의 현재 위치는 자동으로 갱신된다. 다음은 <span class="keyword">write_data</span>( ) 메소드를 이용한 예이다. LO를 만들고 데이터를 저장한다.</p>
<p class="code">csql&gt;CALL new_lo() ON CLASS glo INTO :wr_lo<br />
csql&gt;CALL write_data(8,’raw data’) TO :wr_lo;</p>
<h6>insert_data( ) 메소드</h6>
<p>이 메소드는 사용자 데이터 버퍼로부터 <span class="keyword">glo</span> 내로 데이터를 삽입한다. 데이터는 현재 위치에 의해 정의된 위치를 시작으로 하여 삽입된다. <span class="keyword">insert_data</span>( ) 메소드의 인수는 두 개이다. 첫 번째 인수는 <span class="keyword">glo</span>로 삽입될 데이터의 유닛에 상응하는 정수이고, 두 번째 인수는 삽입될 데이터를 포함하고 있는 버퍼이다.현재 위치는 자동으로 갱신되며, 다음 연산이 시작될 위치를 나타내게 된다. <span class="keyword">insert_data</span>( )가 성공적으로 수행되면 <span class="keyword">glo</span>로 입력된 데이터의 양이 반환된다.</p>
<p class="code">csql&gt;CALL insert_data(3,’end’) ON :wr_lo;</p>
<h6>delete_data( ) 메소드</h6>
<p>이 메소드는 현재 위치에서 시작하는 <span class="keyword">glo</span> 데이터를 삭제한다. 메소드는 첫 번째 인수에 명시된 수만큼의 유닛을 제거한다. 삭제가 성공하면 제거된 유닛의 수가 반환된다. 삭제할 유닛의 수가 <span class="keyword">glo</span> 데이터의 끝부분을 넘어가면 시스템은 절단(truncate)을 수행하고, 실제로 제거된 유닛의 수를 반환한다. 데이터가 삭제될 때 현제 위치는 변하지 않는다. &#160;<span class="keyword">data_size</span>( ) 호출 후에 <span class="keyword">delete_data</span>( )를 호출하면 할당된 바이트 수가 출력된다. 다수의&#160;삭제와 삽입 후에는 <span class="keyword">glo</span>의 조각 모으기를 위해 <span class="keyword">compress_data</span>( ) 메소드를 호출해야 한다.</p>
<p class="code">csql&gt;CALL delete_data(3) ON :wr_lo;</p>
<h6>truncate_data( ) 메소드</h6>
<p>이 메소드는 현재 위치에서부터 <span class="keyword">glo</span> 데이터의 끝까지 모든 데이터를 제거한다. <span class="keyword">truncate_data</span>( ) 메소드는 인수가 없다. 성공적으로 절단이 수행되면 삭제된 유닛의 수가 반환된다.</p>
<p class="code">csql&gt; call truncate_data() on :wr_lo into :num_deleted</p>
<h6>append_data( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 데이터의 끝 부분에 데이터를 추가한다. 메소드의 인수는 두 개이다. 첫 번째 인수는 추가할 유닛의 수를 명시한다. 두 번째 인수는 추가될 데이터를 가지고 있는 버퍼이다. 추가 연산이 성공적으로 수행되면 추가된 유닛의 수가 반환된다. 현재 위치는 추가된 <span class="keyword">glo</span> 데이터의 끝으로 자동 갱신된다. &#160;</p>
<p class="code">csql&gt;call append_data( 14, 'appended_data' ) on :wr_lo</p>
<h6>data_size( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span>가 가지고 있는 모든 유닛의 개수를 반환한다. 갱신 메소드를 이용하여 <span class="keyword">glo</span>에 데이터를 추가하거나 삭제할 수 있기 때문에 데이터의 크기는 변할 수 있다. 메소드의 사용 예는 다음과 같으며, 유닛의 총 개수는 <span class="keyword">total_units</span> 변수에 저장되어 반환된다</p>
<p class="code">csql&gt;call data_size () on :wr_lo</p>
<h6>compress_data( ) 메소드</h6>
<p>이 메소드는 좀 더 효과적인 공간 사용을 위해 LO 데이터를 재구성한다. <span class="keyword">compress_data</span>( ) 메소드는 다수의 <span class="keyword">delete</span>( ) 또는 <span class="keyword">insert</span>( ) 메소드 수행 후에 호출할 것을 권장한다. 메소드가 성공적으로 수행되면 0이 반환되고, 실패하면 0보다 작은 값이 반환된다.</p>
<p class="code">csql&gt;CALL compress_data() ON :wr_lo;</p>
<p>다수의 삭제와 삽입 후에는 <span class="keyword">compress_data</span>( ) 를 수행하여 <span class="keyword">glo</span> 조각 모으기를 해야 한다.</p>
<h6>destroy_data( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 데이터를 제거한다. 메소드는 <span class="keyword">size</span> 속성, 현재 위치, <span class="keyword">header_size</span> 속성을 모두 0으로 설정한 후 완료된다. 메소드가 성공적으로 수행되면 0을 반환하고, 그렇지 않으면 -1을 반환한다.</p>
<p class="code">csql&gt;CALL destroy_data() ON :wr_lo;</p>
<h6>copy_from( ) 메소드</h6>
<p>이 메소드는 데이터 원본(파일 또는 다른 <span class="keyword">glo</span> 인스턴스)에서 <span class="keyword">glo</span> 내로 데이터를 복사한다. <span class="keyword">copy_from</span>( ) 메소드의 인수로는 파일 경로명을 가지는 문자열이나, 다른 <span class="keyword">glo</span> 인스턴스가 사용될 수 있다. 메소드가 성공적으로 수행되면 기존의 <span class="keyword">glo</span> 인스턴스에 덮어쓰기를 하고, 새로운 <span class="keyword">glo</span>의 크기를 반환한다.</p>
<p class="code">csql&gt;CALL new_lo() ON CLASS glo INTO :lob;<br />
csql&gt;CALL copy_from(‘test.txt’)<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ON :lob INTO :size;</p>
<p class="note"><span class="note-title">참고</span> <span class="keyword">glo</span>를 더 작은 데이터를 포함하는 새로운 파일로 덮어쓸&#160;때, <span class="keyword">glo</span>의 마지막에 원치 않는 데이터를 삭제하기 위해 <span class="keyword">truncate_data</span>( )를 호출하지 않는다면, 그 결과로 <span class="keyword">glo</span> 객체는 원래 크기를 계속 유지하게 된다.</p>
<h6>copy_to( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 데이터로부터 파일이나 다른 <span class="keyword">glo</span>로 데이터를 복사한다. <span class="keyword">copy_to</span>( ) 메소드는 파일 경로명을 나타내는 문자열이나, 다른 <span class="keyword">glo</span> 인스턴스를 인수로 갖는다. 메소드가 성공적으로 수행되면 복사된 데이터의 크기가 반환된다.</p>
<p class="code">csql&gt;CALL copy_to(‘extract.txt’) ON :lob &#160;INTO :size_value;</p>
<h6>glo_pathname( ) 메소드</h6>
<p>이 메소드는 <span class="keyword">glo</span> 인스턴스가 FBO일 경우에 경로명을 반환한다. <span class="keyword">glo</span> 인스턴스가 LO이면 <span class="keyword">NULL</span>을 반환한다. 이 메소드는&#160;인수를 갖지&#160;않는다. 다음 예에서 <span class="keyword">glo</span>가 FBO이면 파일 경로명을, LO이면 <span class="keyword">NULL</span>을 <span class="keyword">file_name</span> 변수에 저장하여 반환한다.</p>
<p class="code">csql&gt; CALL glo_pathname() ON :fbo INTO :file_name;</p>
<h6>get_error( ) 메소드</h6>
<p>에러 발생시 에러 원인에 따른 값을 반환한다. 다음은 <span class="keyword">get_error</span>( )가 반환하는 에러 값이다.</p>
<p class="code">INVALID_STRING_INPUT_ARGUMENT -2 &#160;&#160;&#160;/* bad input argument&#160;&#160;&#160;*/<br />
INVALID_INTEGER_INPUT_ARGUMENT -3 &#160;&#160;/* bad input argument &#160;&#160;*/<br />
INVALID_STRING_OR_OBJ_ARGUMENT -4&#160;&#160;&#160;/* bad input argument&#160;&#160;&#160;*/<br />
INVALID_OBJECT_INPUT_ARGUMENT -5 &#160;&#160;&#160;/* bad input argument&#160;&#160;&#160;*/<br />
UNABLE_TO_FIND_GLO_STRUCTURE -6 &#160;&#160;&#160;&#160;/* internal error &#160;&#160;&#160;&#160;&#160;&#160;*/<br />
COULD_NOT_ACQUIRE_WRITE_LOCK -7&#160;&#160;&#160;&#160;&#160;/* object already locked*/<br />
ERROR_DURING_TRUNCATION -8 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* truncation error &#160;&#160;&#160;&#160;*/<br />
ERROR_DURING_DELETE -9 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* delete error &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
ERROR_DURING_INSERT -10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* insert error &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
ERROR_DURING_WRITE -11 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* write error &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
ERROR_DURING_READ -12 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* read error &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
ERROR_DURING_SEEK -13 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* seek error &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
ERROR_DURING_APPEND -14 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* append error &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
ERROR_DURING_MIGRATE -15 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* migrate error &#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
COPY_TO_ERROR -16 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* copy to error &#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br />
COPY_FROM_ERROR -17 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* copy from error &#160;&#160;&#160;&#160;&#160;*/<br />
COULD_NOT_ALLOCATE_SEARCH_BUFFERS -18&#160;&#160;&#160;&#160;&#160;&#160;/* search error &#160;*/<br />
COULD_NOT_COMPILE_REGULAR_EXPRESSION -19&#160;&#160;&#160;/* reg exp error */<br />
COULD_NOT_RESET_WORKING_BUFFER -20 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* search error &#160;*/</p>
<p><span class="keyword">get_error</span>( ) 메소드의 예는 다음과 같다.</p>
<p class="code">csql&gt;CALL get_error() ON :fbo INTO :error_value;</p>
<h6>set_error( ) 메소드</h6>
<p>사용자에 의해 <span class="keyword">glo</span> 클래스 계층이 확장된 경우 <span class="keyword">set_error</span>( ) 메소드를 이용하여 <span class="keyword">get_error</span>( ) 메소드에서 반환하는 에러 값을 추가할 수 있다.</p>
<p class="code">csql&gt; CALL set_error(:user_method_error) ON :fbo;</p>
<script type="text/javascript" language="javascript1.2">//<![CDATA[
<!--
if (window.writeIntopicBar)
	writeIntopicBar(0);


highlightSearch();
//-->
//]]></script>
</body>
</html>
